package autocompchem.chemsoftware.spartan;

/*   
 *   Copyright (C) 2016  Marco Foscato 
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import javax.vecmath.Point3d;

import org.openscience.cdk.Atom;
import org.openscience.cdk.AtomContainer;
import org.openscience.cdk.AtomContainerSet;
import org.openscience.cdk.CDKConstants;
import org.openscience.cdk.interfaces.IAtom;
import org.openscience.cdk.interfaces.IAtomContainer;
import org.openscience.cdk.interfaces.IAtomContainerSet;
import org.openscience.cdk.interfaces.IBond.Order;

import autocompchem.atom.AtomUtils;
import autocompchem.chemsoftware.errorhandling.ErrorManager;
import autocompchem.chemsoftware.errorhandling.ErrorMessage;
import autocompchem.constants.ACCConstants;
import autocompchem.files.FilesAnalyzer;
import autocompchem.files.FilesManager;
import autocompchem.io.IOtools;
import autocompchem.molecule.MolecularUtils;
import autocompchem.parameters.ParameterStorage;
import autocompchem.run.Terminator;

/**
 * Reader and analyzer of Spartan Output files. A defined list of 
 * {@link ErrorMessage}s can be recognized and interpreted.
 * 
 * @author Marco Foscato
 */

public class SpartanOutputHandler
{

    /**
     * Name of the output file from Spartan: the input of this class
     */
    private String inFile;

    /**
     * Name of the molecule
     */
    private String molName = "none";

    /**
     * Name of the output file for tasks run by this worker
     */
    private String outFile;

    /**
     * Format for molecular structure output
     */
    private String outFormat = "XYZ";

    /**
     * List of known errors messages
     */
    private ArrayList<ErrorMessage> errorDef;

    /**
     * Verbosity level
     */
    private int verbosity = 0;

    /**
     * Flag recording normal termination of the Spartan job
     */
    private boolean normalTermiated;

    /**
     * Flag recording whether the error is understood
     */
    private boolean errorIsDecoded;

    /**
     * The class corresponding to the error found in the Spartan file
     */
    private ErrorMessage actualEM;

    /**
     * Counters found and current value
     */
    private Map<String,Integer> counters = new HashMap<String,Integer>();


//------------------------------------------------------------------------------

    /**
     * Constructs an empty output handler
     */

    public SpartanOutputHandler() 
    {
    }

//------------------------------------------------------------------------------

    /**
     * Constructs an SpartanOutputHandler specifying the parameterso
     * taken from formatted file or generated by other tools.
     * All the parameters must be in the form specified as follows:
     * <ul>
     * <li>
     * <b>INFILE</b>: path or name of the root of the Spartan work 
     * environment
     * (i.e. mol.spartan).
     * </li>
     * <li>
     * (optional)<b>MOLNAME</b>: the name of the molecule to extract. By
     * convention of Spartan the name of the molecule is also the name of
     * the folder under which the data for that molecule are stored, and
     * which is located under the root folder of the Spartan document.
     * For instance:
     * <pre>&lt;root&gt;/&lt;molname&gt;</pre>
     * </li>
     * <li>
     * (optional)<b>SPRTERRORS</b>: path to the folder storing 
     * Spartan known
     * {@link ErrorMessage}s.
     * </li>
     * <li>
     * (optional) <b>VERBOSITY</b>: verbosity level.
     * </li>
     * <li>
     * (optional) <b>OUTFILE</b>: name of the file where output 
     * molecular
     * structure will be saved. If multiple output file are produced 
     * the string given via this option will be used a root of all 
     * output file names
     * </li>
     * <li>
     * (optional) <b>OUTFORMAT</b> (default XYZ):
     * format for molecular structure file.
     * Currently available options: XYZ, SDF, SDFXYZ (both XYZ and 
     * SDF).
     * </li>
     * </ul>
     * 
     * @param params object <code>ParameterStorage</code> containing 
     * all the parameters needed
     */

    public SpartanOutputHandler(ParameterStorage params) 
    {
        //Define verbosity
        if (params.contains("VERBOSITY"))
        {
            String vs = params.getParameter("VERBOSITY").getValue().toString();
            this.verbosity = Integer.parseInt(vs);
        }

        if (verbosity > 0)
            System.out.println(" Adding parameters to SpartanOutputHandler");

        //Get and check the input file (which is an output from Spartan)
        this.inFile = params.getParameter("INFILE").getValue().toString();
        FilesManager.foundAndPermissions(this.inFile,true,false,false);
        this.molName = FilesManager.getRootOfFileName(this.inFile);

        //Get cutomized molname
        //Get and check the list of known errors
        if (params.contains("MOLNAME"))
        {
            this.molName = params.getParameter("MOLNAME").getValue().toString();
        }

        //Get and check the list of known errors
        if (params.contains("SPRTERRORS"))
        {
            String errDefPath = 
                      params.getParameter("SPRTERRORS").getValue().toString();
            if (verbosity > 0)
            {
                System.out.println(" Importing known errors from "+ errDefPath);
            }
            FilesManager.foundAndPermissions(errDefPath,true,false,false);
            this.errorDef = ErrorManager.getAll(errDefPath);
            if (verbosity > 0)
            {
                System.out.println(" Imported " + this.errorDef.size() 
                                                             + " known errors");
            }
        }

        //Get and check the output file
        if (params.contains("OUTFILE"))
        {
            this.outFile = 
                         params.getParameter("OUTFILE").getValue().toString();
            FilesManager.mustNotExist(this.outFile);
        } 
        else
        {
            this.outFile = FilesManager.getRootOfFileName(this.inFile);
        }

        //Get and check the output file
        if (params.contains("OUTFORMAT"))
        {
            this.outFormat =
                         params.getParameter("OUTFORMAT").getValue().toString();
        }

    }

//------------------------------------------------------------------------------

    /**
     * Analyses the input file and identify its properties: 
     * termination status, type of errors, geometries, and so on.
     * In case of normal termination it can extract the last geometry. To this
     * end you must provide the OUTFILE and OUTFORMAT options 
     * when generating the handler.
     */

    public void performAnalysis()
    {
        // Check for notmal termination
        String slash = System.getProperty("file.separator");
        String sprtStatus = inFile + slash + SpartanConstants.STATUSFILENAME;
        FilesManager.foundAndPermissions(sprtStatus,true,false,false);
        if (FilesAnalyzer.count(sprtStatus, 
                                          SpartanConstants.NORMALCOMPLSTATUS)>0)
        {
            normalTermiated = true;
            if (verbosity > 0)
            {
                System.out.println(" The Spartan job has terminated normally!");
            }
        }
        else
        {
            if (verbosity > 0)
            {
                System.out.println(" The job did not terminate normally ");
            }
        }

        //Error identififcation
        String sprtOutputLog = inFile + slash + molName + slash + 
                                                SpartanConstants.OUTPUTFILENAME;
        if (!normalTermiated && errorDef != null)
        {
            if (verbosity > 0)
            {
                System.out.println(" Attempting identification of error");
            }

            // Read "tail" of output, but for now read all of it!
            ArrayList<String> tail = IOtools.tailFrom(sprtOutputLog,0);

            //Compare with known errors
            identifyErrorMessage(tail);

            //Report
            if (verbosity > 0)
            {
                if (errorIsDecoded)
                {
                    System.out.println(" Spartan Error Recognized as "
                                        + actualEM.getName());
                } 
                else 
                {
                    System.out.println(" Spartan Error NOT Recognized. Please "
                                + "identify the error by hand and then add a "
                                + "new ErrorMessage to the list of known "
                                + "errors.");
                }
            }
        } 
        if (verbosity > 1)
        {
            System.out.println(" " + getResultsAsString());
        }
    }

//------------------------------------------------------------------------------

    /**
     * Extract the last geometry from the Spartan output loaded in the handler
     * @return the last geometry
     */

    public IAtomContainer extractLastOutputGeometry()
    {
        ArrayList<IAtomContainer> allGeoms = getAllGeometries();
        if (allGeoms.size() == 0)
        {
            Terminator.withMsgAndStatus("ERROR! No geometry found under '" 
                                                           + inFile + "'.", -1);
        }
        IAtomContainer mol = allGeoms.get(allGeoms.size()-1);
        return mol;
    }

//------------------------------------------------------------------------------

    /**
     * Extract the last geometry from an Spartan job folder file 
     * @param sprtRoot pathname of the Spartan job root folder 
     * (i.e., mol.spartan) 
     * @return the last geometry
     */

    public IAtomContainer extractLastOutputGeometry(String sprtRoot)
    {
        this.inFile = sprtRoot;
        return extractLastOutputGeometry();
    }

//------------------------------------------------------------------------------

    /**
     * Prints all the geometries found in the loaded Spartan output file. 
     * All geometries
     * of all tasks are considered.
     */

    public void printTrajectory()
    {
        ArrayList<IAtomContainer> allGeoms = getAllGeometries();
        IAtomContainerSet mols = new AtomContainerSet();
        for (IAtomContainer iac : allGeoms)
        {
            mols.addAtomContainer(iac);
        }
        switch (outFormat.toUpperCase())
        {
            case "SDF":
                if (!outFile.endsWith(".sdf"))
                {
                    outFile = outFile + ".sdf";
                }
                IOtools.writeSDFAppendSet(outFile,mols,false);
                break;

            case "XYZ":
                if (!outFile.endsWith(".xyz"))
                {
                    outFile = outFile + ".xyz";
                }
                IOtools.writeXYZAppendSet(outFile,mols,false);
                break;

            case "SDFXYZ":
                IOtools.writeXYZAppendSet(outFile + ".xyz",mols,false);
                IOtools.writeSDFAppendSet(outFile + ".sdf",mols,false);
                break;

            default:
                Terminator.withMsgAndStatus("ERROR! Format '" + outFormat
                    + "' cannot be use for output in this context. Try SDF,"
                    + " XYZ, or SDFXYZ (will print both).",-1);
        }
    }

//------------------------------------------------------------------------------

    /**
     * Extract the last geometry from the last task found in the loaded Spartan
     * output file and prints it to file according to the parameters defined by 
     * constructor.
     */

    public void printLastOutputGeometry()
    {
        IAtomContainer mol = extractLastOutputGeometry();
        switch (outFormat.toUpperCase())
        {
            case "SDF":
                if (!outFile.endsWith(".sdf"))
                {
                    outFile = outFile + ".sdf";
                }
                IOtools.writeSDFAppend(outFile,mol,false);
                break;

            case "XYZ":
                if (!outFile.endsWith(".xyz"))
                {
                    outFile = outFile + ".xyz";
                }
                IOtools.writeXYZAppend(outFile,mol,false);
                break;

            case "SDFXYZ":
                IOtools.writeXYZAppend(outFile + ".xyz",mol,false);
                IOtools.writeSDFAppend(outFile + ".sdf",mol,false);
                break;

            default:
                Terminator.withMsgAndStatus("ERROR! Format '" + outFormat 
                    + "' cannot be use for output in this context. Try SDF,"
                    + " XYZ, or SDFXYZ (will print both).",-1);
        }
    }

//------------------------------------------------------------------------------

    /**
     * Analize the output and identify the error (if this is known)
     * @param tail the portion of Spartan output file corresponding to the last
     * step
     */

    private void identifyErrorMessage(ArrayList<String> tail)
    {
        errorIsDecoded = false;
        for (ErrorMessage em : errorDef)
        {
            //Get the error message of this candidate error
            ArrayList<String> emLines = em.getErrorMessage();
            int numParts = emLines.size();

            if (verbosity > 1)
                System.out.println(" -> Trying with "+em.getName()+" <-");

            //Read .out file from bottom to top  looking for the error messages
            int numFound = 0;
            for (int i=(tail.size() - 1); i>-1; i--)
            {
                String line = tail.get(i);
                line = line.trim();
                for (String emLine : emLines)
                {
                    if (verbosity > 4)
                    {
                        System.out.println("Comparing line: \n_"
                                            + line
                                            + "_\n_"
                                            + emLine + "_");
                    }

                    if (line.contains(emLine))
                    {
                        numFound++;
                        if (verbosity > 3)
                        {
                            System.out.println("Error message '" + emLine 
                                                                + "' found");
                        }
                        break;
                    }
                }
                if (numFound == numParts)
                {
                    errorIsDecoded = true;
                    actualEM = em;
                    break;
                }
            } //end loop over tail lines

            if (errorIsDecoded)
            {
                //Are there other conditions this .out has to fulfill?
                ArrayList<String> conditions = em.getConditions();
                int numberOfConditions = conditions.size();
                if (numberOfConditions != 0)
                {
                    int numTrue = 0;
                    for (String cond : conditions)
                    {
                        String[] p = cond.split("\\s+");
                        String task = p[0];
                        task = task.toUpperCase();

                        if (verbosity > 3)
                        {
                            System.out.println("Task: "+task);
                        }
                        
                        boolean isSatisfied = false;

                        switch (task)
                        {
                            case "MATCH" :
                            {
                                String pattern = cond.substring(task.length());
                                String[] pp = pattern.split("\"");
                                pattern = pp[1];
                                pattern = pattern.toUpperCase();
                                for (int it=0; it<tail.size(); it++)
                                {
                                    String line = tail.get(it);
                                    line = line.toUpperCase();
//                                    System.out.println("Comparing= __"+line+"__with__"+pattern);
//                                    System.out.println("Result: "+(line.contains(pattern)));
                                    if (line.contains(pattern))
                                    {
                                        isSatisfied = true;
                                        if (verbosity > 3)
                                        {
                                            System.out.println("Match "
                                                     + "condition satisfied by "
                                                     + "text '" + line + "'");
                                        }
                                        break;
                                    }
                                }
//                              System.out.println("isSatisfied="+isSatisfied);
                                break;
                            }
                            case "NOTMATCH" :
                            {
                                boolean patternFound = false;
                                String pattern = cond.substring(task.length());
                                String[] pp = pattern.split("\"");
                                pattern = pp[1];
                                pattern = pattern.toUpperCase();
                                for (int it=0; it<tail.size(); it++)
                                {
                                    String line = tail.get(it);
                                    line = line.toUpperCase();
                                    if (line.contains(pattern))
                                    {
                                        patternFound = true;
                                        if (verbosity > 3)
                                        {
                                            System.out.println("notMatch "
                                                        + "condition could NOT "
                                                        + "be satisfied. "
                                                        + "Pattern found in "
                                                        + " text '" +line+ "'");
                                        }
                                        break;
                                    }
                                }
                                if (!patternFound)
                                {
                                    isSatisfied = true;
                                    if (verbosity > 3)
                                    {
                                        System.out.println("notMatch condition "
                                                                + "satisfied.");
                                    }
                                }
                                break;
                            }

                            case "CHECK_COUNTER":  
                                //This condition is meant for loops with a 
                                // named index 

                                //Get identifier and limit of counter
                                String counterName = cond.substring(
                                                                 task.length());
                                String[] pp = counterName.split("\"");
                                counterName = pp[1];
                                counterName = counterName.toUpperCase();
                                int counterLimit = -1;
                                try {
                                    counterLimit = Integer.parseInt(p[2]);
                                } catch (Throwable t) {
                                    Terminator.withMsgAndStatus("ERROR! "
                                        + "Unable to read loop limit in error " 
                                        + em.getName(),-1);
                                }

                                //Get the current value of the counter
                                int counterValue = -1;
                                for (int it=0; it<tail.size(); it++)
                                {
                                    String line = tail.get(it);
                                    line = line.toUpperCase();
                                    if (line.contains(counterName))
                                    {
                                        if (verbosity > 3)
                                        {
                                            System.out.println("Counter " 
                                                + counterName + " found!");
                                        }
                                        String[] words = line.split("\\s+");
                                        for (int iw=0; iw<words.length; iw++)
                                        {
                                            String w = words[iw];
                                            if (w.contains(counterName))
                                            {
                                                String[] ppp = w.split("=");
                                                try {
                                                    counterValue = 
                                                       Integer.parseInt(ppp[1]);
                                                } catch (Throwable t) {
                                                    Terminator.withMsgAndStatus(
                                                        "ERROR! Unable to read "
                                                        + "value of counter "
                                                        + counterName + " in "
                                                        + w,-1);
                                                }
                                                break;
                                            }
                                        }

                                        //Make sure we got the number
                                        if (counterValue < 0)
                                        {
                                            Terminator.withMsgAndStatus(
                                                          "ERROR! Unable to "
                                                        + "read loop value in "
                                                        + line,-1);
                                        }
                                    
                                        break;
                                    } 
                                }

                                //Check condition
                                if (counterValue >= counterLimit)
                                {
                                    Terminator.withMsgAndStatus("Maximum "
                                    + "number of cycles reaches for " 
                                    + em.getName() + ". " + counterName
                                    + " = " + counterValue + " (limit="
                                    + counterLimit +").",-1);
                                } else if (counterValue > 0) {
                                    if (verbosity > 1)
                                    {
                                        System.out.println(" Counter '" 
                                        + counterName
                                        + "' is still within the limit (next "
                                        + "iteration will have index "
                                        + (counterValue + 1) + " <= " 
                                        + counterLimit + ").");
                                    }
                                    counters.put(counterName,counterValue);
                                    isSatisfied = true;
                                } else {
                                    if (verbosity > 1)
                                    {
                                        System.out.println(" Check counter "
                                            + "condition is not verified: " 
                                            + "counter "
                                            + counterName + " not found.");
                                    }
                                }
                                break;

/*
TODO add other tasks here
                            case "":
                                ...do something...
                                break;

*/

                            default:
                                Terminator.withMsgAndStatus("ERROR! Condition "
                                        + task + " not known! "
                                        + "Check definition of error " 
                                        + em.getName(),-1);
                        }
                                        
                        if (!isSatisfied)
                            break;
                        else 
                            numTrue++;
                    }

                    if (numberOfConditions != numTrue)
                        errorIsDecoded = false;
                }

                //Nothing else to do if the error is identified
                if (errorIsDecoded)
                    break;
            }
        } //end loop over known errors

    }

//------------------------------------------------------------------------------

    /**
     * Method clarifying whether the error behind a not-normally terminated job
     * has been identified by this SpartanOutputHandler or not.
     * @return <code>true</code> if Spartan error message has been understood
     */

    public boolean isErrorUnderstood()
    {
        return errorIsDecoded;
    }

//------------------------------------------------------------------------------

    /**
     * Method returning the {@link ErrorMessage} of a not-normally terminated
     * job.
     * @return the ErrorMessage identified from Spartan .out file
     */

    public ErrorMessage getErrorMessage()
    {
        return actualEM;
    }

//------------------------------------------------------------------------------

    /**
     * Method returning AutoCompChem counters stored in Spartan output file.
     * @return the map of counters with counter names and values
     */

    public Map<String,Integer> getCounters()
    {
        return counters;
    }

//------------------------------------------------------------------------------

    /**
     * Get all geometries from a Spartan output tree.
     * Geometries are taken from the archive. 
     * @return the set of molecules defined as atoms and coords 
     * (no connectivity)
     */

    public ArrayList<IAtomContainer> getAllGeometries()
    {
        String slash = System.getProperty("file.separator");
        String sprtArchFile = inFile + slash + molName + slash
                                             + SpartanConstants.ARCHIVEFILENAME;
        String sprtInpFile = inFile + slash + molName + slash
                                               + SpartanConstants.INPUTFILENAME;
        FilesManager.foundAndPermissions(sprtArchFile,true,false,false);
        FilesManager.foundAndPermissions(sprtInpFile,true,false,false);

        //Get number of lines of each block (i.e., number of atoms)
        ArrayList<ArrayList<String>> firstGeom =
                      FilesAnalyzer.extractMultiTxtBlocksWithDelimiters(
                                                                   sprtArchFile,
                                                  SpartanConstants.ARCHSTARTXYZ,
               SpartanConstants.ARCHENERGYLAB+"|"+SpartanConstants.ARCHBASISLAB,
                                                                          false,
                                                                         false);

        int nAtms = firstGeom.get(0).size();
        if (nAtms < 1)
        {
            Terminator.withMsgAndStatus("ERROR! Unable to find number of atoms "
                              + "in archive '" + sprtArchFile + "'.",-1);
        }

        // Read in molecular befinition blocks
        ArrayList<ArrayList<String>> blocks = 
                      FilesAnalyzer.extractMultiTxtBlocksWithDelimiterAndSize(
                                                                   sprtArchFile,
                                                  SpartanConstants.ARCHSTARTXYZ,
                                                                          nAtms,
                                                                         false);
        // Make molecular objects from text
        ArrayList<IAtomContainer> molList = new ArrayList<IAtomContainer>();
        for (ArrayList<String> singleBlock : blocks)
        {
            molList.add(getIAtomContainerFromXYZblock(singleBlock));
        }

        // Get number of atoms
        System.out.println(" WARNING! Assuming that all geometries have the "
                                     + "same number of atoms and connectivity");

        // Get connectivity block
        blocks = FilesAnalyzer.extractMultiTxtBlocksWithDelimiters(sprtInpFile,
                                                       SpartanConstants.TOPOOPN,
                                                       SpartanConstants.TOPOEND,
                                                                           true,
                                                                         false);

        // Get connectivity
        if (blocks.size() == 1)
        {
            ArrayList<int[]> cnTab = new ArrayList<int[]>();
            int nAtmTypesFound = 0;
            for (String line : blocks.get(0))
            {
                // Need to check for keyword abbreviation
                if (line.toUpperCase().startsWith(SpartanConstants.TOPOOPN) ||
                    line.toUpperCase().startsWith(SpartanConstants.TOPOEND))
                {
                    continue;
                }

                String[] parts = line.trim().split("\\s+");

                //read (and for now ignore) the atom type section
                if (nAtmTypesFound < nAtms)
                {
                   nAtmTypesFound = nAtmTypesFound +  parts.length;
                   continue;
                }
        
                try
                {
                    cnTab.add(new int[] {Integer.parseInt(parts[0]), 
                                         Integer.parseInt(parts[1]),
                                         Integer.parseInt(parts[2])});
                }
                catch (Throwable t)
                {
                    System.out.println("WARNING! Could not read connectivity "
                                                + "from line '" + line + "'. ");
                    break;
                }
            }
            // WARNING! Assuming that all geometries have the same connectivity
            for (int[] ids : cnTab)
            {
                Order o = MolecularUtils.intToBondOrder(ids[2]); 
                for (IAtomContainer mol : molList)
                {
                    mol.addBond(ids[0]-1,ids[1]-1,o);
                }
            }
        }
        else
        {
            Terminator.withMsgAndStatus("ERROR! Unable to deal with Spartan "
                        + SpartanConstants.INPUTFILENAME + " file that has "
                        + "none or more than one '" + SpartanConstants.TOPOOPN 
                        + "' block. Check file '" + sprtInpFile + "'.",-1);
        
        }

        return molList;
    }

//------------------------------------------------------------------------------

    /**
     * Reads a Cartesian coordinates table, in the format from Spartan output 
     * file (including header) and return the corresponding molecular 
     * representation (without connectivity). It converts the coordinates
     * from Bohr (units in Spartan files) to Angtrom (units in XYZ).
     * @param lines the list of lines corresponding to the XYZ table
     * @return the molecule obtained
     */

    public IAtomContainer getIAtomContainerFromXYZblock(ArrayList<String> lines)
    {
        double b2a = 1.0 / ACCConstants.ANGSTOMTOBOHR;
        IAtomContainer mol = new AtomContainer();
        mol.setProperty(CDKConstants.TITLE,molName);
        for (int i=0; i<lines.size(); i++)
        {
            String[] parts = lines.get(i).trim().split("\\s+");
            try
            {
                String el = AtomUtils.getElementalSymbol(
                                                     Integer.parseInt(parts[0]));
                Point3d p3d = new Point3d(Double.parseDouble(parts[1]) * b2a,
                                          Double.parseDouble(parts[2]) * b2a,
                                          Double.parseDouble(parts[3]) * b2a);
                IAtom atm = new Atom(el,p3d);
                mol.addAtom(atm);
            }
            catch (Throwable t)
            {
                Terminator.withMsgAndStatus("ERROR! Unable to convert line '"
                        + lines.get(i) + "' into an atom while reading Spartan "
                        + "file.",-1);
            }
        }
        return mol;
    }

//------------------------------------------------------------------------------

    /**
     * Returns a string summarizing the results of the evaluation 
     * @return the summary as a string
     */

    public String getResultsAsString()
    {
        String str = "Root:" + inFile + " NormalTerm:"
                        + normalTermiated + " Error:";
        if (errorIsDecoded)
            str = str + actualEM.getName();
        else
            str = str + "Not Known";

        return str;
    }

//------------------------------------------------------------------------------

}
