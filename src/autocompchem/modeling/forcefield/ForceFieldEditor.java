package autocompchem.modeling.forcefield;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

import org.openscience.cdk.AtomType;

import autocompchem.chemsoftware.tinker.TinkerForceFieldHandler;
import autocompchem.chemsoftware.vibmodule.VibModuleOutputHandler;
import autocompchem.files.FilesManager;
import autocompchem.parameters.ParameterStorage;
import autocompchem.run.Terminator;
import autocompchem.smarts.SMARTS;
import autocompchem.utils.NumberAwareStringComparator;


/**
 * ForceFieldEditor is a toolbox for modifying force field parameters.
 *
 * @author Marco Foscato
 */

public class ForceFieldEditor
{
    /**
     * The pathname of the input force field file
     */
    private String iFFFile = "noInpFF";

    /**
     * The pathname of the output force field file
     */
    private String oFFFile = "noOutFF";

    /**
     * The pathname/s of the molecular structure files
     */
    private ArrayList<String> molFiles = new ArrayList<String>();

    /**
     * The pathname/s of the vibrational analysis files
     */
    private ArrayList<String> vaFiles = new ArrayList<String>();

    /**
     * The format of vibrational analysis file
     */
    private String vaFormat = ForceFieldConstants.VIBANLVIBMODULE;

    /**
     * Flag controlling no-output mode
     */
    private boolean noOutput = false;

    /**
     * The format for input force field file
     */
    private String inFFFormat = ForceFieldConstants.FFFILETNKFORMAT;

    /**
     * The format for output
     */
    @SuppressWarnings("unused")
        private String outFormat;

    /**
     * Storage of SMARTS queries
     */
    private Map<String,String> smarts = new HashMap<String,String>();

    /**
     * Storage of options associated with SMARTS queries
     */
    private Map<String,ArrayList<String>> smartsOpts =
                                        new HashMap<String,ArrayList<String>>();

    /**
     * Label used to identify single-atom smarts in the smarts reference name.
     * WARNING! Must be consistent with that of VibModuleOutputHandler.
     */
    private static final String SUBRULELAB = "_p";

    /**
     * Root of the smarts reference names.
     * WARNING! Must be consistent with that of VibModuleOutputHandler.
     */
    private static final String MSTRULEROOT = "smarts ";

    /**
     * Unique counter for SMARTS reference names
     */
    private final AtomicInteger iNameSmarts = new AtomicInteger(0);

    /**
     * Storage of SMARTS-to-atom type rules
     */
    private Map<String,Map<String,String>> smartsToAtmTyp = 
                                       new HashMap<String,Map<String,String>>();

    /**
     * Loaded force field parameters set
     */
    private ForceFieldParamsSet ff = new ForceFieldParamsSet();

    /**
     * Verbosity level
     */
    private int verbosity = 1;

//------------------------------------------------------------------------------

    /**
     * Constructor for an empty ForceFieldEditor
     */

    public ForceFieldEditor() 
    {
    }

//------------------------------------------------------------------------------

    /**
     * Constructs a ForceFieldEditor specifying the parameters taken from 
     * formatted file or generated by other tools.
     * Parameters to be defined are:
     * <ul>
     * <li><b>INPFFFILE</b>: set the pathname to the force field file to be 
     * read in.</li>
     * <li>(optional) <b>OUTFFFILE</b>: set the pathname of the output 
     * force field file</li>
     * <li>(optional) <b>OUTFORMAT</b>: set the format of the output force
     * field file.</li>
     * <li>(optional) <b>MOLFILES</b>: set one or more pathname to 
     * molecular structure files. A multi line blocks can be used to provide
     * more than one pathname (one pathname per each line).</li>
     * <li>(optional) <b>VAFILES</b>: set one or more pathname to
     * VibModule output files. Such files are often used to extract force field
     * parameters derived from vibrational analysis of QM models. 
     * A multi line blocks can be used to provide
     * more than one pathname (one pathname per each line).</li>
     * <li>(optional) <b>VAFORMAT</b>: set the format of the vibrational
     * analysis files (default=
     * {@value autocompchem.modeling.forcefield.ForceFieldConstants#VIBANLVIBMODULE})</li>
     * <li>(optional) <b>INTCOORDBYSMARTS</b>: set SMARTS-based rules that
     * define of the internal 
     * coordinates (IC), and the corresponding force field energy terms, for 
     * which force field parameters are to be extracted from the VibModule file.
     * A multi line block (see {@link autocompchem.parameters.Parameter})
     * can be used defining one IC-defining rule per line. Each such lines
     * must contain first the <i>N</i>-tupla of
     * single atom SMARTS queries (where <i>N</i> is 2, 3, or 4), and next the
     * keyword defining the type of IC:
     * {@value autocompchem.chemsoftware.vibmodule.VibModuleConstants#TYPSTR}
     * for bond stretches,
     * {@value autocompchem.chemsoftware.vibmodule.VibModuleConstants#TYPBND}
     * for angle bending,
     * {@value autocompchem.chemsoftware.vibmodule.VibModuleConstants#TYPOOP}
     * for out-of-plane angles (with the central atom being in 4th position)
     * {@value autocompchem.chemsoftware.vibmodule.VibModuleConstants#TYPTOR}
     * for bond torsion.</li>
     * <li>(optional<b>SMARTSTOATOMTYPEMAP</b>: defines the relation between 
     * single-atom SMARTS queries and atom types/classes. The syntax of one rule
     * can be 
     * <pre>[SMARTSquery] type=[TID]</pre>,
     * where <code>[SMARTSquery]</code> is the SMARTS query, 
     * and <code>[TID]</code> the atom type ID, or
     * <pre>[SMARTSquery] type=[TTT] class=[CID]</pre>
     * where <code>[CID]</code> is the atom class IID.
     * A multi line block (see {@link autocompchem.parameters.Parameter}) can be
     * used with one rule per line.</li>
     * <li>(optional) <b>VERBOSITY</b>: set the verbosity level.</li>
     * </ul>
     * @param params object <code>ParameterStorage</code> containing all the
     * parameters needed
     */

    public ForceFieldEditor(ParameterStorage params) 
    {
        //Define verbosity
        if (params.contains("VERBOSITY"))
        {
            String v = params.getParameter("VERBOSITY").getValue().toString();
            this.verbosity = Integer.parseInt(v);
        }
        if (verbosity > 0)
        {
            System.out.println(" Adding parameters to ForceFieldEditor");
        }

        //Get and check initial force field file
        this.iFFFile = params.getParameter("INPFFFILE").getValue().toString();
        FilesManager.foundAndPermissions(this.iFFFile,true,false,false);

        //Get force field format
        if (params.contains("INFFFORMAT"))
        {
            this.inFFFormat =
                        params.getParameter("INFFFORMAT").getValue().toString();
        }

        //Get the force field parameters set
        importForceField(this.iFFFile,this.inFFFormat);


        //Get and check molecular structure file (or files)
        if (params.contains("MOLFILES"))
        {
            String lst = params.getParameter("MOLFILES").getValue().toString();
            String[] files = lst.split(System.getProperty("line.separator"));
            for (int i=0; i<files.length; i++)
            {
                FilesManager.foundAndPermissions(files[i],true,false,false);
                this.molFiles.add(files[i]);
            }
        }

        //Get and check vibrational analysis files
        if (params.contains("VAFILES"))
        {
            String lst = params.getParameter("VAFILES").getValue().toString();
            String[] files = lst.split(System.getProperty("line.separator"));
            for (int i=0; i<files.length; i++)
            {
                FilesManager.foundAndPermissions(files[i],true,false,false);
                this.vaFiles.add(files[i]);
            }
        }

        //Import smarts
        if (params.contains("INTCOORDBYSMARTS"))
        {
            String all =
                  params.getParameter("INTCOORDBYSMARTS").getValue().toString();
            this.smarts.putAll(getNamedICSMARTS(all));
            this.smartsOpts.putAll(getOptsForNamedICSMARTS(all,this.smarts));
        }

        //Optional parameters
        if (params.contains("OUTFFFILE"))
        {
            //Get and check output file
            this.oFFFile = 
                         params.getParameter("OUTFFFILE").getValue().toString();
            FilesManager.mustNotExist(this.oFFFile);
        } else {
            noOutput=true;
        }

        //Get force field format
        if (params.contains("OUTFORMAT"))
        {
            if (noOutput)
            {
                String cause = "ERROR! ForceFieldEditor: OUTFORMAT defined"
                                + " while running in no-output mode";
                Terminator.withMsgAndStatus("ERROR! " + cause,-1);
            }
            this.outFormat = 
                        params.getParameter("OUTFORMAT").getValue().toString();
        }

        if (params.contains("SMARTSTOATOMTYPEMAP"))
        {
            String[] lines = params.getParameter("SMARTSTOATOMTYPEMAP").
              getValue().toString().split(System.getProperty("line.separator"));
            for (int i=0; i<lines.length; i++)
            {
                String l = lines[i].trim();
                if (l.equals(""))
                {
                    continue;
                }
                String[] words = l.split("\\s+");
                if (words.length < 2)
                {
                    Terminator.withMsgAndStatus("ERROR! Expecting more than "
                         + "one space-separated words in line '" + l + "'.",-1);
                }
                if (!SMARTS.isSingleAtomSMARTS(words[0]))
                {
                    Terminator.withMsgAndStatus("ERROR! Expecting SMARTS in "
                                                      + "line '" + l + "'.",-1);
                }
                Map<String,String> opts = new HashMap<String,String>();
                for (int j=1; j<words.length; j++)
                {
                    String[] kv = words[j].split("=");
                    if (kv.length != 2)
                    {
                        Terminator.withMsgAndStatus("ERROR! Expecting syntax "
                                      + " 'key=value' in line '" + l + "'.",-1);
                    }
                    if (kv[0].toUpperCase().equals(
                            ForceFieldConstants.ATMTYPSTRMAP)
                        || kv[0].toUpperCase().equals(
                            ForceFieldConstants.ATMCLSSTRMAP))
                    {
                        opts.put(kv[0].toUpperCase(),kv[1]);
                    }
                    else
                    {
                        opts.put(kv[0],kv[1]);
                    }
                }
                smartsToAtmTyp.put(words[0],opts);
            }
        }
    }

//------------------------------------------------------------------------------

    /**
     * Imports a force field parameter set from file.
     * @param filename the pathname to the force field file
     * @param format the format of the force field file
     */
    private void importForceField(String filename, String format)
    {
        switch (format)
        {
            case ForceFieldConstants.FFFILETNKFORMAT:
                ff = TinkerForceFieldHandler.readFromFile(filename);
                break;

            default:
                Terminator.withMsgAndStatus("ERROR! Force field file format '" 
                                            + format + "' in not known. Cannot "
                                            + "import the force field.",-1);
        }        
    }

//------------------------------------------------------------------------------

    /**
     * Export the currently loaded force field parameter set into file.
     * @param filename the pathname to the force field file
     * @param format the format of the force field file
     */
    private void exportForceField(String filename, String format)
    {
        switch (format)
        {
            case ForceFieldConstants.FFFILETNKFORMAT:
                TinkerForceFieldHandler.writeForceFieldFile(ff,filename);
                break;

            default:
                Terminator.withMsgAndStatus("ERROR! Force field file format '"
                                            + format + "' in not known. Cannot "
                                            + "export the force field.",-1);
        }
    }

//------------------------------------------------------------------------------

    /**
     * Imports force constants and equilibrium values from the 
     * vibrational analysis of given molecules into a force field. Settings
     * from the constructor.
     */

    public void includeFFParamsFromVibModule()
    {
        // Check consistency
        String msg = "";
        if (molFiles.size() == 0 || vaFiles.size() == 0
            || molFiles.size() != vaFiles.size())
        {
            msg = "Inconsistent number of structures (" + molFiles.size() 
                  + ") or vibrational analysis files (" + vaFiles.size() + "). "
                  + "Check input parameters!";
            Terminator.withMsgAndStatus("ERROR! " + msg,-1);
        }
        else
        {
            if (verbosity > 0)
            {
                System.out.println("Importing force field parameters from "
                                   + vaFiles.size() + " vibrational analysis.");
            }
        }

        // Get new (averaged) force field parameters from vibrational analysis
        ForceFieldParameterStats ffParStats = new ForceFieldParameterStats();
        switch (vaFormat)
        {
            case ForceFieldConstants.VIBANLVIBMODULE:
                for (int imol=0; imol<molFiles.size(); imol++)
                {
                    VibModuleOutputHandler vmoh = new VibModuleOutputHandler(
                                                             molFiles.get(imol),
                                                              vaFiles.get(imol),
                                                                         smarts,
                                                                     smartsOpts,
                                                                     verbosity);
                    ffParStats.addAllFFParams(vmoh.getFFParams());
                }
                break;

            default:
                msg = "Format '" + vaFormat + "' is not among the known "
                      + "formats of vibrational analysis files";
                Terminator.withMsgAndStatus("ERROR! " + msg,-1);
                break;
        }

        //Assign atom type/class
        if (verbosity > 0)
        {
            System.out.println(" Mean force field parameters (over all " 
                            + molFiles.size() + " mols):");
        }
        for (ForceFieldParameter ffp : ffParStats.getMeanFFPar())
        {
            for (AtomType at : ffp.getAtomTypes())
            {
                String smartsKey = at.getProperty(
                            ForceFieldConstants.SMARTSQUERYATMTYP).toString();
                if (!smartsToAtmTyp.keySet().contains(smartsKey))
                {
                    msg = " WARNING! No atom type/class definition for SMARTS '"
                            + smartsKey + "'. Cannot assign force field "
                            + "parameter " + ffp.toSimpleString();
                    System.out.println(msg);
                    ffp.setProperty("IGNORE","IGNORE");
                }
                else
                {
                    //TODO
                    System.out.println("===>>FOUDN MAP for "+smartsKey);
                    Map<String,String> atOpts = smartsToAtmTyp.get(smartsKey);
                    if (atOpts.keySet().contains(
                        ForceFieldConstants.ATMTYPSTRMAP))
                    {
                        at.setProperty(ForceFieldConstants.ATMTYPSTR,
                            atOpts.get(ForceFieldConstants.ATMTYPSTRMAP));
                    }
                    if (atOpts.keySet().contains(
                        ForceFieldConstants.ATMCLSSTRMAP))
                    {
                        at.setProperty(ForceFieldConstants.ATMCLSSTR,
                            atOpts.get(ForceFieldConstants.ATMCLSSTRMAP));
                    }
                }
                if (ffp.hasProperty("IGNORE"))
                {
                    break;
                }
            }
            if (verbosity > 0 && !ffp.hasProperty("IGNORE"))
            {
                System.out.println("  -> "+ffp.toSimpleString());
            }
        }

        //Import new parameter into the loaded FF parameters' set
//TODO
System.out.println("TODO!!!");




        //Write results
        if (!noOutput)
        {
            exportForceField(this.oFFFile,this.inFFFormat);
        }
    }

//-----------------------------------------------------------------------------

    /**
     * Reads SMARTS for defining internal coordinates.
     * This methos collects all non-single-atom SMARTS strings found in a
     * given string. The string is
     * assumend to contain one or more lines (i.e., newline-character separated)
     * and each line to contain from 2 to 4 space-separated single-atom SMARTS.
     * @param allLines the string collecting all lines and including newline
     * characters
     * @return the map of all named smarts. Naming is based on incremental and
     * unique indexing where a major index is used to identify sets of SMARTS
     * red from the same line, and anothe idex is used to identify the
     * order of the SMARTS red in the same line.
     */

//TODO: move this method to utils for SMARTS, and replace it in other classes
// line NWChemInputWriter

    private Map<String,String> getNamedICSMARTS(String allLines)
    {
        Map<String,String> map = new HashMap<String,String>();
        if (verbosity > 1)
        {
            System.out.println(" Importing SMARTS to identify ICs");
        }
        String[] lines = allLines.split("\\r?\\n");
        int ii = -1;
        for (int i=0; i<lines.length; i++)
        {
            if (lines[i].trim().equals(""))
            {
                continue;
            }
            // This allows to retrace the exact orded in which lines are
            // given, yet without using the line number as index and allowing
            // to store multiple blocks of SMARTS queries in the same map
            ii = iNameSmarts.getAndIncrement();
            String masterName = MSTRULEROOT + ii;

            String[] parts = lines[i].split("\\s+");
            int jj = -1;
            for (int j=0; j<parts.length; j++)
            {
                String singleSmarts = parts[j].trim();

                // Ignore any string that is not a single-atom SMARTS
                if (singleSmarts.equals("") ||
                    !SMARTS.isSingleAtomSMARTS(singleSmarts))
                {
                    continue;
                }

                if (jj > 3)
                {
                    Terminator.withMsgAndStatus("ERROR! More than 4 atomic "
                               + "SMARTS for IC-defining SMARTS rule "
                               + ii + " (last SMARTS:" + singleSmarts + "). "
                               + "These rules must identify N-tuples of "
                               + "atoms, where N=2,3,4. Check the input.",-1);
                }
                jj++;
                String childName = masterName + SUBRULELAB + jj;
                map.put(childName,singleSmarts);
            }
            if (jj < 1)
            {
                Terminator.withMsgAndStatus("ERROR! Less than 2 atomic "
                               + "SMARTS for IC-defining SMARTS rule "
                               + ii + ". These rules must identify N-tuples of "
                               + "atoms, where N=2,3,4. Check input.",-1);
            }
        }
        return map;
    }

//------------------------------------------------------------------------------

    /**
     * Read options and values associated with SMARTS queries.
     * This methos collects all non-single-atom SMARTS strings found in a
     * given string. The string is
     * assumend to contain one or more lines (i.e., newline-character separated)
     * and each line to contain from 2 to 4 space-separated single-atom SMARTS.
     * @param allLines the string collecting all lines and including newline
     * characters
     * @param smarts the map of previously red SMARTS queries for which this
     * method is collecting the options
     * @return the map of all named details. Naming is based on incremental and
     * unique indexing where an integer index is used to identify the list of
     * strings red from the same line.
     */

//TODO: move this method to utils for SMARTS, and replace it in other classes
// line NWChemInputWriter

    private Map<String,ArrayList<String>> getOptsForNamedICSMARTS(
                                     String allLines, Map<String,String> smarts)
    {
        ArrayList<String> sortedMasterNames = getSortedSMARTSRefNames(smarts);

        Map<String,ArrayList<String>> map =
                                        new HashMap<String,ArrayList<String>>();
        if (verbosity > 1)
        {
            System.out.println(" Importing options for IC-identifying SMARTS");
        }
        String[] lines = allLines.split("\\r?\\n");
        int ii=-1;
        for (int i=0; i<lines.length; i++)
        {
            if (lines[i].trim().equals(""))
            {
                continue;
            }
            ii++;
            String[] parts = lines[i].split("\\s+");
            ArrayList<String> lstDetails = new ArrayList<String>();
            for (int j=0; j<parts.length; j++)
            {
                String str = parts[j].trim();

                // Ignore single-atom SMARTS
                if (str.equals("") || SMARTS.isSingleAtomSMARTS(str))
                {
                    continue;
                }

                lstDetails.add(str);
            }
            map.put(sortedMasterNames.get(ii),lstDetails);
        }
        return map;
    }

//------------------------------------------------------------------------------

    /**
     * get the sorted list of master names
     */

    private ArrayList<String> getSortedSMARTSRefNames(
                                                      Map<String,String> smarts)
    {
        ArrayList<String> sortedMasterNames = new ArrayList<String>();
        for (String k : smarts.keySet())
        {
            String[] p = k.split(SUBRULELAB);
            if (!sortedMasterNames.contains(p[0]))
            {
                sortedMasterNames.add(p[0]);
            }
        }
        Collections.sort(sortedMasterNames, new NumberAwareStringComparator());
        return sortedMasterNames;
    }

//-----------------------------------------------------------------------------

}
