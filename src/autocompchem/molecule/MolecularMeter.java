package autocompchem.molecule;

/*   
 *   Copyright (C) 2014  Marco Foscato 
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.concurrent.atomic.AtomicInteger;

import org.openscience.cdk.interfaces.IAtom;
import org.openscience.cdk.interfaces.IAtomContainer;

import autocompchem.io.IOtools;
import autocompchem.run.Terminator;
import autocompchem.io.SDFIterator;
import autocompchem.files.FilesManager;
import autocompchem.parameters.ParameterStorage;
import autocompchem.smarts.ManySMARTSQuery;
import autocompchem.molecule.MolecularUtils;

/**
 * MolecularMeter collects measuring tools for molecular quantities
 * such as inter atomic distances, angles, and dihedral angles. Quantities
 * can be defined from SMARTS queries or atom indexes.
 * 
 * @author Marco Foscato
 */


public class MolecularMeter
{
    /**
     * Unique counter for naming quantities
     */
    private final AtomicInteger CRDID = new AtomicInteger(0);

    /**
     * Pathname to the file containing the molecules to analyze
     */
    private String inFile;

    /**
     * Pathname to the file where to write the output
     */
    private String outFile;

    /**
     * Map of the SMARTS queries used to define the quantities to measure
     */
    private Map<String,String> smarts = new HashMap<String,String>();

    /**
     * Map of the atom indexes used to define the quantities to measure
     */
    private Map<String,ArrayList<Integer>> atmIds = 
                                       new HashMap<String,ArrayList<Integer>>();

    /**
     * Map defining the type of quantity definition 
     */
    private Map<String,String> defTypes = new HashMap<String,String>();

    /**
     * List of the named descriptors in the order requested by the user
     */
    private ArrayList<String> sortedKeys = new ArrayList<String>();

    /**
     * Flag: consider only bonded atoms
     */
    private boolean onlyBonded = false;

    /**
     * Storage of results (per molecule)
     */
    private ArrayList<Map<String,ArrayList<Double>>> results = 
                                new ArrayList<Map<String,ArrayList<Double>>>();

    /**
     * Flag notifying that the meter has run 
     */
    private boolean alreadyRun = false;

    /**
     * Verbosity level
     */
    private int verbosity = 1;

//------------------------------------------------------------------------------

    /**
     * Constructor for an empty MolecularMeter
     */

    public MolecularMeter() 
    {
    }

//------------------------------------------------------------------------------

    /**
     * Constructs a MolecularMeter specifying the parameters taken from 
     * formatted file or generated by other tools. 
     * Parameters that need/can be given to setup the meter
     * <ul>
     * <li> 
     * <b>INFILE</b> pathname of the SDF/XYZ file containing the structures
     * Multiple structures can be provided 
     * </li>
     * <li>
     * (optional)<b>SMARTS</b> single or multi line argument providing the 
     * definition of the quantities to be measured. 
     * Each line codifies for a single quantity. All lines should respect the 
     * following format:<br>
     * <code>key [smarts1] [smarts2] [smarts3] [smarts4]</code><br>
     * where
     * <ul>
     * <li>
     *  <code>key</code> is a string identifying the type of quantity 
     * (<b>DIST</b> for inter atomic distances, <b>ANG</b> for angles, and
     *  <b>DIH</b> for dihedral angles);
     * </li>
     * <li>
     * <code> [smarts1] ... [smarts4]</code> are single atom SMARTS used
     * to identify the target atoms. Note that the number of single atom SMARTS
     * queries depends on the type of quantity to be measured. 
     * Moreover, note that the list is ordered,
     * meaning that, for instance, to calculate the angle between
     * the three atoms A-B-C, 
     * the SMARTS will have to be provided with the exact order
     * <code>[A]</code> <code>[B]</code> <code>[C]</code>.
     * </li>
     * </ul>
     * (optional)<b>ATOMINDEXES</b> single or multi line argument providing the
     * atom indexes (1-based) defining the quantities to be measured. 
     * Each line codifies for a single quantity. All lines should respect the
     * following format:<br>
     * <code>key &lt;ID1&gt; &lt;ID2&gt; &lt;ID3&gt; &lt;ID4&gt; </code><br>
     * where each &lt;ID&gt; is an integer. The number of indexes defined the
     * type of quantity, i.e., distance, angle, or dihedral.
     * </li>
     * <li>
     * (optional)<b>ONLYBONDED: TRUE</b> option to restrict the analysis to
     * sequences of bonded atoms.
     * </li>
     * <li>
     * <b>VERBOSITY</b>  verbosity level
     * </li>
     * </ul>
     * 
     * @param params object <code>ParameterStorage</code> containing all the
     * parameters needed
     */

    public MolecularMeter(ParameterStorage params) 
    {
        //Define verbosity
        String vStr = params.getParameter("VERBOSITY").getValue().toString();
        this.verbosity = Integer.parseInt(vStr);

        if (verbosity > 0)
            System.out.println(" Adding parameters to MolecularMeter");


        //Get and check the input file (which has to be an SDF file)
        this.inFile = params.getParameter("INFILE").getValue().toString();
        FilesManager.foundAndPermissions(this.inFile,true,false,false);

        //Get SMARTS based definition of quantities
        if (params.contains("SMARTS"))
        {
            String allSmarts = 
                    params.getParameter("SMARTS").getValue().toString();
            if (verbosity > 0)
            {
                System.out.println(" Importing SMARTS queries ");
            }
            String[] lines = allSmarts.split("\\r?\\n");
            for (int i=0; i<lines.length; i++)
            {
                addRule(lines[i],"S");
            }
        }

        //Get atom indexes definition of quantities
        if (params.contains("ATOMINDEXES"))
        {
            String allIDs =
                       params.getParameter("ATOMINDEXES").getValue().toString();
            if (verbosity > 0)
            {
                System.out.println(" Importing atom indexes ");
            }
            String[] lines = allIDs.split("\\r?\\n");
            for (int i=0; i<lines.length; i++)
            {
                addRule(lines[i],"A");
            }
        }
        
        //Check for consistency
        if (!params.contains("SMARTS") && !params.contains("ATOMINDEXES"))
        {
            String msg = "ERROR! Neither 'SMARTS' nor 'ATOMINDEXES' keywords"
                            + " found. No definition of quantities to measure!";
            Terminator.withMsgAndStatus(msg,-1);
        }

        //Get optional parameter
        if (params.contains("ONLYBONDED"))
        {
            String val = 
                params.getParameter("ONLYBONDED").getValue().toString();
            if (val.toUpperCase().equals("TRUE"))
            {
                this.onlyBonded = true;
            }
        }
    }

//------------------------------------------------------------------------------

    /**
     * Appends a quantity-defining rule
     * @param line the string defining a single quantity
     * @param type the string defining the type of rule: "S" for SMARTS, "A" for
     * atom indexes
     */

    private void addRule(String line, String type)
    {
        String[] parts = line.split("\\s+");
        String key = parts[0] + "-" + CRDID.getAndIncrement();
        this.sortedKeys.add(key);
        this.defTypes.put(key,type);
        if (type.equals("S"))
        {
            for (int j=1; j<parts.length; j++)
            {
                String singleSmarts = parts[j];
                if (singleSmarts.equals(""))
                    continue;
                String k2 = key + "_" + Integer.toString(j-1);
                this.smarts.put(k2,singleSmarts);
            }
        }
        else if (type.equals("A"))
        {
            ArrayList<Integer> ids = new ArrayList<Integer>();
            for (int j=1; j<parts.length; j++)
            {
                if (parts[j].equals(""))
                    continue;
                try
                {
                    ids.add(Integer.parseInt(parts[j]));
                }
                catch (Throwable t)
                {
                    String msg = "ERROR! Unable to convert index '" + parts[j] 
                               + "' into an integer. Check line '" + line + "'";
                    Terminator.withMsgAndStatus(msg,-1);
                }
            }
            this.atmIds.put(key,ids);
        }
    }
  
//------------------------------------------------------------------------------

    /**
     * Measure all the quantities required according to the information
     * provided to the constructor. The values of the measured quantities are
     * reported in the log (if verbosity lever higher than 0) or recovered 
     * from this MolecularMeter with the method {@link #getAllResults} and
     * {@link #getSingleResults getSingleResults}.
     */

    public void measureAllQuantities()
    {
        int i = 0;
        try {
            ArrayList<IAtomContainer> mols = IOtools.readMultiMolFiles(inFile);
            for (IAtomContainer mol : mols) 
            {
                // Get the molecule
                i++;
                boolean skipMol = true;
                String molName = MolecularUtils.getNameOrID(mol);
                if (verbosity > 0)
                {
                    System.out.println(" Analyzing molecule " + i);
                }

                // Get target atoms                
                Map<String,ArrayList<ArrayList<IAtom>>> allQuantities =
                              new HashMap<String,ArrayList<ArrayList<IAtom>>>();
                if (smarts.keySet().size() > 0)
                {
                    if (verbosity > 1)
                    {
                        System.out.println(" Matching SMARTS queries");
                    }
                    ManySMARTSQuery msq = new ManySMARTSQuery(mol,smarts,
                                                                     verbosity);
                    if (msq.hasProblems())
                    {
                        String cause = msq.getMessage();
                        Terminator.withMsgAndStatus("ERROR! " +cause,-1);
                    }
    
                    Map<String,ArrayList<IAtom>> targetGroups = 
                                         new HashMap<String,ArrayList<IAtom>>();
                    for (String key : smarts.keySet())
                    {
                        ArrayList<IAtom> atomsMatched = new ArrayList<IAtom>();
                        if (msq.getNumMatchesOfQuery(key) == 0)
                        {
                            System.out.println("WARNING! No match for SMARTS "
                                                   + "query " + smarts.get(key)
                                                   + " in molecule " + i + ".");
                            break;
                        }
                        else
                        {
                            skipMol = false;
                        }
                        List<List<Integer>> allMatches = msq.getMatchesOfSMARTS(
                                                                           key);
                        for (List<Integer> innerList : allMatches)
                        {
                            for (Integer iAtm : innerList)
                            {
                                IAtom targetAtm = mol.getAtom(iAtm);
                                atomsMatched.add(targetAtm);
                            }
                        }
                        targetGroups.put(key,atomsMatched);
                    }

                    // Collect matches that belong to same quantity
                    for (String key : sortedKeys)
                    {
                        ArrayList<String> groups = new ArrayList<String>();
                        for (String k2 : targetGroups.keySet())
                        {
                            if (k2.toUpperCase().startsWith(key.toUpperCase()))
                            {
                                groups.add(k2);
                            }
                        }
                        ArrayList<ArrayList<IAtom>> atmsForQuantity =
                                        new ArrayList<ArrayList<IAtom>>();
                        for (int ig = 0; ig<groups.size(); ig++)
                        {
                            String k2qry = key + "_" + Integer.toString(ig);
                            atmsForQuantity.add(targetGroups.get(k2qry));
                        }
                        allQuantities.put(key,atmsForQuantity);
                    }
                }

                if (atmIds.keySet().size() > 0)
                {
                    if (verbosity > 1)
                    {
                        System.out.println(" Matching atoms from indexes");
                    }
                    skipMol = false;
                    for (String key : atmIds.keySet())
                    {
                        ArrayList<ArrayList<IAtom>> atmsForQuantity =
                                              new ArrayList<ArrayList<IAtom>>();
                        for (Integer id : atmIds.get(key))
                        {
                            ArrayList<IAtom> altAtms = new ArrayList<IAtom>();
                            //
                            // WARNING! Change from 1- to 0-based indexing
                            //
                            altAtms.add(mol.getAtom(id-1)); 
                            atmsForQuantity.add(altAtms);
                        }
                        allQuantities.put(key,atmsForQuantity);
                    }
                }
    
                //In case of no match
                if (skipMol)
                {
                    results.add(null);
                    continue;
                }

                //Prepare storage of results
                Map<String,ArrayList<Double>> resThisMol = 
                                        new HashMap<String,ArrayList<Double>>();

                //Measure all quantities
                for (String key : sortedKeys)
                {
                    if (!allQuantities.containsKey(key))
                    {
                        if (verbosity > 1)
                        {
                            System.out.println(" No quantity '" + key 
                                                                  + "' found.");
                        }
                        continue;
                    }

                    ArrayList<ArrayList<IAtom>> atmsForQuantity = 
                                                         allQuantities.get(key);
                    if (key.toUpperCase().startsWith("DIST"))
                    {
                        //Measure distance A-B
                        ArrayList<Double> distances = new ArrayList<Double>();
                        for (IAtom atmA : atmsForQuantity.get(0))
                        {
                            for (IAtom atmB : atmsForQuantity.get(1))
                            {
                                if (atmA.equals(atmB))
                                    continue;

                                if (onlyBonded)
                                {
                                    if (
                                !mol.getConnectedAtomsList(atmA).contains(atmB))
                                    {
                                        continue;
                                    }
                                }

                                double res = 
                                   MolecularUtils.calculateInteratomicDistance(
                                                                          atmA,
                                                                          atmB);

                                //Report value
                                if (verbosity > 0)
                                {
                                    String strRes = "Mol." + i + " " 
                                        + molName + " "
                                        + " Dst."
                                        + key + " "
                                        + MolecularUtils.getAtomRef(atmA,mol) 
                                        + ":"
                                        + MolecularUtils.getAtomRef(atmB,mol) 
                                        + " = "
                                        + res;
                                    System.out.println(strRes);
                                }
                                distances.add(res);
                            }
                        }

                        //Store results for this molecule
                        resThisMol.put(key,distances);

                    } 
                    else if (key.toUpperCase().startsWith("ANG"))
                    {
                        //Measure angle A-B-C
                        ArrayList<Double> angles = new ArrayList<Double>();
                        for (IAtom atmA : atmsForQuantity.get(0))
                        {
                            for (IAtom atmB : atmsForQuantity.get(1))
                            {
                                if (atmA.equals(atmB))
                                    continue;

                                if (onlyBonded)
                                {
                                    if (
                                !mol.getConnectedAtomsList(atmA).contains(atmB))
                                    {
                                        continue;
                                    }
                                }

                                for (IAtom atmC : atmsForQuantity.get(2))
                                {
                                    if (atmB.equals(atmC))
                                        continue;

                                    if (atmA.equals(atmC))
                                        continue;

                                    if (onlyBonded)
                                    {
                                        if (
                                !mol.getConnectedAtomsList(atmB).contains(atmC))
                                        {
                                            continue;
                                        }
                                    }
                                
                                    double res = 
                                            MolecularUtils.calculateBondAngle(
                                                                        atmA,
                                                                        atmB,
                                                                        atmC);
                                    //Report value
                                    if (verbosity > 0)
                                    {
                                        String strRes = "Mol." + i + " " 
                                            + molName + " " + " Ang."
                                                + key + " "
                                    + MolecularUtils.getAtomRef(atmA,mol) + ":"
                                    + MolecularUtils.getAtomRef(atmB,mol) + ":"
                                    + MolecularUtils.getAtomRef(atmC,mol) +" = "
                                            + res;
                                        System.out.println(strRes);
                                    }
                                    angles.add(res);
                                }
                            }
                        }

                        //Store results for this molecule
                        resThisMol.put(key,angles);

                    } 
                    else if (key.toUpperCase().startsWith("DIH"))
                    {
                        //Measure dihedral angle A-B-C-D
                        ArrayList<Double> dihedrals = new ArrayList<Double>();
                        for (IAtom atmA : atmsForQuantity.get(0))
                        {
                            for (IAtom atmB : atmsForQuantity.get(1))
                            {
                                if (atmA.equals(atmB))
                                    continue;

                                if (onlyBonded)
                                {
                                    if (
                                !mol.getConnectedAtomsList(atmA).contains(atmB))
                                    {
                                        continue;
                                    }
                                }
                                
                                for (IAtom atmC : atmsForQuantity.get(2))
                                {
                                    if (atmB.equals(atmC))
                                        continue;

                                    if (atmA.equals(atmC))
                                        continue;

                                    if (onlyBonded)
                                    {
                                        if (
                                !mol.getConnectedAtomsList(atmB).contains(atmC))
                                        {
                                            continue;
                                        }
                                    }

                                    for (IAtom atmD : atmsForQuantity.get(3))
                                    {
                                        if (atmC.equals(atmD))
                                            continue;
                                        if (atmB.equals(atmD))
                                            continue;
                                        if (atmA.equals(atmD))
                                            continue;

                                        if (onlyBonded)
                                        {
                                            if (
                                !mol.getConnectedAtomsList(atmC).contains(atmD))
                                            {                                   
                                                continue;                       
                                            }
                                        }

                                        double res = 
                                        MolecularUtils.calculateTorsionAngle(
                                                                        atmA,
                                                                        atmB,
                                                                        atmC,
                                                                        atmD);

                                        //Report value
                                        if (verbosity > 0)
                                        {
                                            String strRes = "Mol." + i + " "
                                                + molName + " " + " Dih."
                                                + key +" "
                                    + MolecularUtils.getAtomRef(atmA,mol) + ":"
                                    + MolecularUtils.getAtomRef(atmB,mol) + ":"
                                    + MolecularUtils.getAtomRef(atmC,mol) + ":"
                                    + MolecularUtils.getAtomRef(atmD,mol) +" = "
                                                + res;
                                            System.out.println(strRes);
                                        }
                                        dihedrals.add(res);
                                    }
                                }
                            }
                        }

                        //Store results for this molecule
                        resThisMol.put(key,dihedrals);

                    } 
                    else 
                    {
                        Terminator.withMsgAndStatus("ERROR! What do you mean "
                          + "with '" + key + "'? Unable to identify the type "
                          + "of quantity to measure.",-1);
                    }
                }

                //Store output
                results.add(resThisMol);
/*
                if (storeInSDF)
                {
                    //TODO: store as properties in SDF file
                }
*/
        
            } //end loop over molecules

        } catch (Throwable t) {
            t.printStackTrace();
            Terminator.withMsgAndStatus("ERROR! Exception returned by "
                + "SDFIterator while reading " + inFile, -1);
        }

        //Set flag
        alreadyRun = true;
    }

//-----------------------------------------------------------------------------

    /**
     * Return the results for all measured quantities. Vectors of values
     * are returned per each molecule in the form of 
     * a map using as keys the strings identifying the quantities
     * (plus an index to avoid duplicate) as
     * provided via the SMARTS parameter when constructing the object.
     * @return the results for all measured quantities
     */

    public ArrayList<Map<String,ArrayList<Double>>> getAllResults()
    {
        if (!alreadyRun)
            this.measureAllQuantities();

        return results;
    }

//-----------------------------------------------------------------------------
    
    /**
     * Return the results for a single molecule and a single quantity. 
     * The molecule is identified by the position (0-n) in the input.
     * The quantity is identified by
     * its position (0-n) in the list of quantities provided to the constructor 
     * by means of the SMARTS parameter. Note that the result for a single 
     * quantity can consist in more than one value, thus a vector is returned.
     * @param molID the index of the molecule for which the result is required
     * @param quantityID the index of the required quantity
     * @return the results for a single molecule and a single quantity
     */

    public ArrayList<Double> getSingleResults(int molID, int quantityID)
    {
        if (!alreadyRun)
            this.measureAllQuantities();

        Map<String,ArrayList<Double>> resThisMol = results.get(molID);
        ArrayList<Double> res = resThisMol.get(sortedKeys.get(quantityID));
        return res;
    }

//-----------------------------------------------------------------------------
}
