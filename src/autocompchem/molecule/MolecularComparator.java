package autocompchem.molecule;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;

/*   
 *   Copyright (C) 2014  Marco Foscato 
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openscience.cdk.interfaces.IAtom;
import org.openscience.cdk.interfaces.IAtomContainer;

import autocompchem.constants.ACCConstants;
import autocompchem.files.FileUtils;
import autocompchem.geometry.DistanceMatrix;
import autocompchem.io.IOtools;
import autocompchem.molecule.connectivity.ConnectivityUtils;
import autocompchem.molecule.coordinationgeometry.CoordinationGeometry;
import autocompchem.molecule.coordinationgeometry.CoordinationGeometryReferences;
import autocompchem.molecule.coordinationgeometry.CoordinationGeometryUtils;
import autocompchem.molecule.geometry.ComparatorOfGeometries;
import autocompchem.run.Terminator;
import autocompchem.smarts.ManySMARTSQuery;
import autocompchem.worker.TaskID;
import autocompchem.worker.Worker;


/**
 * Compare molecular structures.
 * 
 * @author Marco Foscato
 */


public class MolecularComparator extends Worker
{
    /**
     * Declaration of the capabilities of this subclass of {@link Worker}.
     */
    public static final Set<TaskID> capabilities =
            Collections.unmodifiableSet(new HashSet<TaskID>(
                    Arrays.asList(TaskID.COMPARETWOMOLECULES,
                    		TaskID.COMPARETWOGEOMETRIES,
                    		TaskID.COMPARETWOCONNECTIVITIES)));
    
    //Filenames
    private String inFile;
    private String refFile;
    private String rotatedFile;
    private String outFile;

    //SMARTS query identifying target atoms
    private String targetAtoms;

    //Verbosity level
    private int verbosity = 1;

//------------------------------------------------------------------------------

    /**
     * Constructor for an empty MolecularComparator
     */
/*
    public MolecularComparator() 
    {
    }
*7
//------------------------------------------------------------------------------

    /**
     * Constructor for an empty MolecularComparator and specify verbosity
     * @param verbosity the verbosity level
     */
/*
    public MolecularComparator(int verbosity)
    {
        this.verbosity = verbosity;
    }
*/
//------------------------------------------------------------------------------

    //TODO move to class doc
    /**
     * Constructs a <code>MolecularComparator</code> specifying the parameters 
     * taken from 
     * formatted file or generated by other tools.
     * Parameters needed by the MolecularComparator:
     * <ul>
     * <li> 
     * <b>INFILE</b> path or name of the SDF file containing the structure
     *            (only SDF files with ONE molecule are acceptable!)
     * </li>
     * <li>
     * <b>REFERENCE</b> path or name of the SDF file containing the reference 
     *            structure (only SDF files with ONE molecule are acceptable!)
     * </li>
     * <li>
     * <b>OUTFILE</b> path or name of the TXT file where results are to be 
     * written.
     * </li>
     * <li>
     * <b>VERBOSITY</b>  verbosity level
     * </li>
     * </ul>
     * Other optional parameters are:
     * <ul>
     * <li>
     * (optional)<b>ROTATEDOUT</b> path or name of the SDF file in which 
     * we report the 
     * rotated structure of the input molecule (from INFILE)
     * </li>
     * <li>
     * (optional)<b>TARGETATOMSQUERY</b> SMARTS query identifying the target 
     * atom of atom specific analysis.
     * </li>
     * </ul>
     * 
     * @param params object <code>ParameterStorage</code> containing all the
     * parameters needed
     */
/*
    public MolecularComparator(ParameterStorage params) 
    {
	*/
    
    /**
     * Initialise the worker according to the parameters loaded by constructor.
     */

    @Override
    public void initialize()
    {
        //Define verbosity
        String vStr = params.getParameter("VERBOSITY").getValue().toString();
        this.verbosity = Integer.parseInt(vStr);

        if (verbosity > 0)
            System.out.println(" Adding parameters to MolecularComparator");

        //Get and check the input file (which has to be an SDF file)
        this.inFile = params.getParameter("INFILE").getValue().toString();
        FileUtils.foundAndPermissions(this.inFile,true,false,false);

        //Get and check the reference file (which has to be an SDF file)
        this.refFile = params.getParameter("REFERENCE").getValue().toString();
        FileUtils.foundAndPermissions(this.refFile,true,false,false);

        //Get and check output file
        if (params.contains("OUTFILE"))
        {
            this.outFile = params.getParameter("OUTFILE").getValue().toString();
            FileUtils.mustNotExist(this.outFile);
        }

        //Get and check optional file for rotated output
        if (params.contains("ROTATEDOUT")) 
        {
            this.rotatedFile = 
                        params.getParameter("ROTATEDOUT").getValue().toString();
            FileUtils.mustNotExist(this.rotatedFile);
        }

        //Get the SMARTS query identifying target atoms
        if (params.contains("TARGETATOMSQUERY")) 
        {
            this.targetAtoms =
                  params.getParameter("TARGETATOMSQUERY").getValue().toString();
        }

    }

//-----------------------------------------------------------------------------

    /**
     * Performs any of the registered tasks according to how this worker
     * has been initialised.
     */

    @SuppressWarnings("incomplete-switch")
    @Override
    public void performTask()
    {
        switch (task)
          {
          case COMPARETWOMOLECULES:
        	  runComparisonOfMoleculesBySuperposition();
              break;
          case COMPARETWOGEOMETRIES:
        	  compareTwoGeometries();
              break;
          case COMPARETWOCONNECTIVITIES:
        	  compareTwoConnectivities();
              break;
          }

        if (exposedOutputCollector != null)
        {
/*
//TODO
            String refName = "";
            exposeOutputData(new NamedData(refName,
                  NamedDataType.DOUBLE, ));
*/
        }
    }

//------------------------------------------------------------------------------

    /**
     * Run comparison of two connectivity matrices as from the parameters given
     * in construction of this comparator
     */

    public void compareTwoConnectivities()
    {
        //Get the molecules
        ArrayList<IAtomContainer> inMols = IOtools.readSDF(inFile);
        if (inMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + inFile ,-1);
        }
        IAtomContainer inMol = inMols.get(0);

        ArrayList<IAtomContainer> refMols = IOtools.readSDF(refFile);
        if (refMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + refFile ,-1);
        }
        IAtomContainer refMol = refMols.get(0);

        ConnectivityUtils cu = new ConnectivityUtils();
        boolean consistentConnectivity = cu.compareWithReference(inMol,refMol);
        if (!consistentConnectivity)
        {
            if (verbosity > 0)
            {
                System.out.println(" Inconsistent adjacency between molecules "
                                 + MolecularUtils.getNameOrID(inMol)
                                 + " and "
                                 + MolecularUtils.getNameOrID(refMol));
            }
        } else {
            if (verbosity > 0)
            {
                System.out.println(" Consistent connectivity");
                if (!outFile.equals("") && outFile != null)
                {
                    IOtools.writeSDFAppend(outFile,inMol,false);
                }
            }
        }
    }

//------------------------------------------------------------------------------

    /**
     * Run comparison of two geometries as from the parameters given in
     * construction of this comparator
     */

    public void compareTwoGeometries()
    {
        //Get the molecules
        ArrayList<IAtomContainer> inMols = IOtools.readSDF(inFile);
        if (inMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + inFile ,-1);
        }
        IAtomContainer inMol = inMols.get(0);

        ArrayList<IAtomContainer> refMols = IOtools.readSDF(refFile);
        if (refMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + refFile ,-1);
        }
        IAtomContainer refMol = refMols.get(0);

        //Get the atoms
        if (targetAtoms.equals("") || targetAtoms == null)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "a SMARTS query to identify the target atom of which the "
                + "geometry is to be compared with a reference structure. "
                + "It seems that the SMARTS was not define. Please provide "
                + "a SMARTS string by means of the keyword:value pair "
                + "TARGETATOMSQUERY: <SMARTS_of_the_central_atom>.", -1);
        }

        //Get the atoms of which geometry have to be compared
        Map<String,String> SMARTSAllInOne = new HashMap<String,String>();
        SMARTSAllInOne.put("center",targetAtoms);

        //For First molecule
        if (verbosity > 2)
        {    
            System.out.println(" Trying to identify the target atom in '"
                + MolecularUtils.getNameOrID(inMol) + "'.");
        }    
        ManySMARTSQuery msq = new ManySMARTSQuery(inMol,SMARTSAllInOne,verbosity);
        if (msq.hasProblems())
        {
            String cause = msq.getMessage();
            if (cause.contains("The AtomType") && 
                                        cause.contains("could not be found"))
            {
                Terminator.withMsgAndStatus("ERROR! " + cause 
                        + " To solve the problem try to move this "
                        + "element to \"Du\" an try again.",-1);
            }
            System.err.println("\nWARNING! Problems in using SMARTS queries. " 
                                + cause);
            System.out.println("Matches: "+msq.getNumMatchesMap());
        } 
        if (msq.getTotalMatches() < 1) {
            Terminator.withMsgAndStatus("ERROR! Unable to find the central "
                + "atom '" + targetAtoms + "' in molecule " 
                + MolecularUtils.getNameOrID(inMol) + ".", -1);
        } 
        else if (msq.getTotalMatches() > 1) 
        {
            Terminator.withMsgAndStatus("ERROR! More than one atom matches the "
                + "given query (" + targetAtoms + "). Unable to unambiguously "
                + "identify the central atom to be analysed",-1);
        }
        int centerID = msq.getMatchesOfSMARTS("center").get(0).get(0);
        IAtom inAtm = inMol.getAtom(centerID);

        //For second molecule
        if (verbosity > 2)
        {
            System.out.println(" Trying to identify the target atom in '"
                + MolecularUtils.getNameOrID(refMol) + "'.");
        }
        ManySMARTSQuery msqR = new ManySMARTSQuery(refMol,SMARTSAllInOne,verbosity);
        if (msqR.hasProblems())
        {
            String cause = msqR.getMessage();
            if (cause.contains("The AtomType") &&
                                        cause.contains("could not be found"))
            {           
                Terminator.withMsgAndStatus("ERROR! " + cause 
                        + " To solve the problem try to move this "
                        + "element to \"Du\" an try again.",-1);
            }   
            System.err.println("\nWARNING! Problems in using SMARTS queries. " 
                                + cause);
            System.out.println("Matches: "+msqR.getNumMatchesMap());
        } 
        if (msqR.getTotalMatches() < 1) {
            Terminator.withMsgAndStatus("ERROR! Unable to find the central "
                + "atom '" + targetAtoms + "' in molecule "
                + MolecularUtils.getNameOrID(refMol) + ".", -1);
        } 
        else if (msqR.getTotalMatches() > 1) 
        {
            Terminator.withMsgAndStatus("ERROR! More than one atom matches the "
                + "given query (" + targetAtoms + "). Unable to unambiguously "
                + "identify the central atom to be analysed",-1);
        }
        int centerIDR = msqR.getMatchesOfSMARTS("center").get(0).get(0);
        IAtom refAtm = refMol.getAtom(centerIDR);

        //RunComparison
        compareTwoGeometries(inAtm, inMol, refAtm, refMol);

    }

//------------------------------------------------------------------------------

    /**
     * Run comparison of the geometries of two atoms in two molecules
     * @param atmA atom of which the geometry has to be compared with the 
     * reference
     * @param molA the first molecule
     * @param atmR atom in the reference molecule (reference geometry)
     * @param molR the reference molecule
     */

    public void compareTwoGeometries(IAtom atmA, IAtomContainer molA, 
                                     IAtom atmR, IAtomContainer molR)
    {
        //Make geometries for the two atoms
        List<IAtom> lsA = molA.getConnectedAtomsList(atmA);
        List<IAtom> lsR = molR.getConnectedAtomsList(atmR);
        if (verbosity > 1)
        {
            System.out.println("Generating CoordinationGeometry 'gA'");
            for (int ia=0; ia<lsA.size(); ia++)
            {
                System.out.println(" " + ia + " atom " + MolecularUtils.getAtomRef(lsA.get(ia),molA));
            }
            System.out.println("Generating CoordinationGeometry 'gB'");
            for (int ir=0; ir<lsR.size(); ir++)
            {
                System.out.println(" " + ir + " atom " + MolecularUtils.getAtomRef(lsR.get(ir),molR));
            }        
        }        
        CoordinationGeometry gA = new CoordinationGeometry("gA", atmA, 
                                              molA.getConnectedAtomsList(atmA));
        CoordinationGeometry gR = new CoordinationGeometry("gR", atmR, 
                                              molR.getConnectedAtomsList(atmR));

        //Compare CN
        int cnA = gA.getConnectionNumber();
        int cnR = gR.getConnectionNumber();

        if (cnA != cnR)
        {
            Terminator.withMsgAndStatus("ERROR! The geometries of target atom '"
                        + MolecularUtils.getAtomRef(atmA,molA) 
                        + "' in molecule "
                        + MolecularUtils.getNameOrID(molA)
                        + " and atom '"
                        + MolecularUtils.getAtomRef(atmR,molR)
                        + "' in molecule "
                        + MolecularUtils.getNameOrID(molR)
                        + " have different CN (" + cnA + ", " + cnR + ").",-1);
        }


        //Compare the two geometries
        double mad = CoordinationGeometryUtils.calculateMeanAngleDifference(
                                                                gA,
                                                                gR,
                                                                verbosity);

        //Build result string
        String summary = MolecularUtils.getAtomRef(atmA,molA) 
                        + "-" + MolecularUtils.getNameOrID(molA)
                        + " " + MolecularUtils.getAtomRef(atmR,molR)
                        + "-" + MolecularUtils.getNameOrID(molR) 
                        + " MAD= " + mad;

        //Compare both against reference geometries with same CN
        
        // TODO: check why we get null if CoordinationGeometryReferences is accessed as static
        CoordinationGeometryReferences cgRefs = new
                                               CoordinationGeometryReferences();
        List<CoordinationGeometry> allReference = 
                                          cgRefs.getReferenceGeometryForCN(cnA);
        for (CoordinationGeometry gRef : allReference)
        {
            double madA =
                CoordinationGeometryUtils.calculateMeanAngleDifference(
                                                                gA,
                                                                gRef,
                                                                0);
            double madR =
                CoordinationGeometryUtils.calculateMeanAngleDifference(
                                                                gR,
                                                                gRef,
                                                                0);
            String nStd = gRef.getName();
            String report = String.format(" MAD_mol;" + nStd + " %1.2f", madA);
            report = report + String.format(" MAD_ref;" + nStd + " %1.2f",madR);
            double diff = (madA - madR);
            report = report + String.format(" D-MAD(" + nStd + ")= %1.2f",diff);
//            System.out.println("->" + gRef.getName() + ": MadA = " + madA
//                                + " MadR = " +madR);
//            System.out.println("D-MAD("+ gRef.getName() + ") = " + (madA-madR));
            
//   summary = summary + " D-MAD("+ gRef.getName() + ")= " + (madA-madR);
            summary = summary + report;
        }

        //In case of debug print the matrix of all-vs-all MAD for the standard gc
        if (verbosity > 2)
        {
            for (int i=2; i<7; i++)
            {
                List<CoordinationGeometry> a = cgRefs.getReferenceGeometryForCN(i);
                CoordinationGeometryUtils.printAllVsAllMAD(a);
            }
        }

        //Report results
        System.out.println(" ");
        System.out.println(" Comparison on two geometries: ");
        System.out.println(summary);
        if (!outFile.equals("") && outFile != null)
        {
            IOtools.writeTXTAppend(outFile,summary,false);
            System.out.println(" Results reported also in file " + outFile);
        }
        
    }

//------------------------------------------------------------------------------

    /**
     * Run comparator as from the parameters given in construction 
     * of the comparator
     */

    public void runComparisonOfMoleculesBySuperposition()
    {
        ArrayList<IAtomContainer> inMols = IOtools.readSDF(inFile);
        if (inMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + inFile ,-1);
        }
        IAtomContainer inMol = inMols.get(0);

        ArrayList<IAtomContainer> refMols = IOtools.readSDF(refFile);
        if (refMols.size() != 1)
        {
            Terminator.withMsgAndStatus("ERROR! MoleculeComparator requires "
                + "SDF files with only one structure. Check file "
                + refFile ,-1);
        }
        IAtomContainer refMol = refMols.get(0);

        ComparatorOfGeometries cog = new ComparatorOfGeometries(verbosity);
        cog.compareGeometryBySuperposition(inMol,refMol);

//TODO: print ourput?

    }

//------------------------------------------------------------------------------

    /**
     * Calculates and return the best atom mapping between two structures:
     * a map of which atom in the first structure corresponds to an atom in the
     * second structure. The result is reported with 0-based indexes in the atom
     * array of each structure, so that
     * the keys are the indexes of atoms in the second (reference)
     * structure while the values are the indexes in the first structure.
     * @param molA the first molecule
     * @param molB the second molecule
     * @return the atom map where keys are atom indexes in the second molecule
     * and values are atom indexes in the first molecule
     */
    public Map<Integer,Integer> getGeometryAwareAtomMapping(IAtomContainer molA,
                                                            IAtomContainer molB)
    {
        ComparatorOfGeometries cog = new ComparatorOfGeometries(verbosity);
        return cog.getAtomMapping(molA,molB);
    }

//------------------------------------------------------------------------------

    /**
     * DO NOT USE: this is incomplete.
     * This method was made to check what would happen when splitting the
     * isomorphism into fragments, but results are not good. So, for now,
     * this is left here as a zoombie...
     * Calculates and return the best atom mapping between two structures:
     * a map of which atom in the first structure corresponds to an atom in the
     * second structure. The result is reported with 0-based indexes in the atom
     * array of each structure, so that
     * the keys are the indexes of atoms in the second (reference)
     * structure while the values are the indexes in the first structure.
     * @param molA the first molecule
     * @param molB the second molecule
     * @return the atom map where keys are atom indexes in the second molecule
     * and values are atom indexes in the first molecule
     */
    private Map<Integer,Integer> guessAtomMapping(IAtomContainer molA,
                                                            IAtomContainer molB)
    {
        //Get fragments according to connectivity
        //WARNING! hard-coded parameter (minimum size of fragments = 2)
        ArrayList<IAtomContainer> fragsA =
                                   ConnectivityUtils.getConnectedFrags(molA,2);
        ArrayList<IAtomContainer> fragsB =
                                   ConnectivityUtils.getConnectedFrags(molB,2);

        for (int i=0; i<fragsA.size(); i++)
        {
            IAtomContainer fA = fragsA.get(i);
//TODO del
IOtools.writeSDFAppend("frags.sdf",fA,true);
        }
        for (int j=0; j<fragsB.size(); j++)
        {
            IAtomContainer fB = fragsB.get(j);
//TODO del
IOtools.writeSDFAppend("frags.sdf",fB,true);
        }

        //Compare single fragmens: all vs. all
        DistanceMatrix dmRmsds = new DistanceMatrix();
        DistanceMatrix dmSizes = new DistanceMatrix();
        Map<Integer,Map<Integer,Map<Integer,Integer>>> allMaps =
                       new HashMap<Integer,Map<Integer,Map<Integer,Integer>>>();
        for (int i=0; i<fragsA.size(); i++)
        {
            IAtomContainer fA = fragsA.get(i);
            allMaps.put(i, new HashMap<Integer,Map<Integer,Integer>>());
            for (int j=0; j<fragsB.size(); j++)
            {
                IAtomContainer fB = fragsB.get(j);

                ComparatorOfGeometries cog = new ComparatorOfGeometries(
                                                                   verbosity-2);
                allMaps.get(i).put(j,cog.getAtomMapping(fA,fB));
                dmRmsds.put(i,j,cog.getAlignementScore());
                dmSizes.put(i,j,cog.getSizeOfMap());
                    
//TODO del
System.out.println("Done with combination "+i+":"+j+" SIZE: "+cog.getSizeOfMap()+" SCORE: "+cog.getAlignementScore());
            }
        }

//TODO del
/*
System.out.println(" ");
for (int i=0; i<fragsB.size(); i++)
{
System.out.println("mx size:"+dmSizes.getMaxDistOnColumn(i));
}
for (int i=0; i<fragsB.size(); i++)
{
System.out.println("min score:"+dmRmsds.getMinDistOnColumn(i));
}
*/

        // Combine the best fragment-fragment matches tu build atom mapping
        Map<Integer,Integer> bestCombination = new HashMap<Integer,Integer>();
        if (fragsA.size() <= fragsB.size())
        {
            ArrayList<Integer> usedFragsJ = new ArrayList<Integer>();
            for (int i=0; i<fragsA.size(); i++)
            {
/*
TODO del
for (IAtom atm : fragsA.get(i).atoms())
{
    System.out.println(" orig: "+atm.getProperty(ACCConstants.ATMIDPROP).toString());
}
*/
                int cmJ = -1;
                double min = Double.MAX_VALUE;
                ArrayList<Double> vals = dmSizes.getAllDistsOnRow(i);
                for (int j=0; j<vals.size(); j++)
                {
                    if (vals.get(j).equals(dmSizes.getMaxDistOnColumn(i)))
                    {
                        if (dmRmsds.get(i,j) < min)
                        {
                            //here we have the max similarity and min RMSD
                            //but need to chekc that fragment "j" is not used
                            if (!usedFragsJ.contains(j))
                            { 
                                min = dmRmsds.get(i,j);
                                cmJ = j;
                            }
                        }
                    }
                }
                usedFragsJ.add(cmJ);
//TODO del
System.out.println("Best j for i="+i+" is j="+cmJ);
                for (Map.Entry<Integer,Integer> e : 
                	allMaps.get(i).get(cmJ).entrySet())
                {
//TODO del
System.out.println("-> Mapped "+e.getKey()+","+e.getValue());
                    int atmInFrgIdJ = Integer.parseInt(e.getKey().toString());
                    int atmInFrgIdI = Integer.parseInt(e.getValue().toString());
                    IAtom atmInFrgA = fragsA.get(i).getAtom(atmInFrgIdI);
                    IAtom atmInFrgB = fragsB.get(cmJ).getAtom(atmInFrgIdJ);
                    int origIdA = Integer.parseInt(atmInFrgA.getProperty(
                                       ACCConstants.ATMIDPROP).toString());
                    int origIdB = Integer.parseInt(atmInFrgB.getProperty(
                                       ACCConstants.ATMIDPROP).toString());

//TODO del
System.out.println("   Translating to old IDs: "+origIdA+","+ origIdB);
                    bestCombination.put(origIdA, origIdB);
                }
            }
        }
        else
        {
            System.out.println("TODO: not implemented yet");
//TODO: write case in which fragsB is smaller than fragsA
System.exit(-1);
        }

        //Now we deal with the remaining atoms
        int szA = molA.getAtomCount();
        int szB = molB.getAtomCount();
        int minSz = 0;
        boolean smallA = true;
        if (szA<=szB)
        {
            minSz = szA;
        }
        else
        {
            minSz = szB;
            smallA = false;
        }
        if (bestCombination.size() < minSz)
        {
            ArrayList<Integer> missingAtmsA = new ArrayList<Integer>();
            for (int i=0; i<szA; i++)
            {
                if (!bestCombination.keySet().contains(i))
                {
                    missingAtmsA.add(i);
                }
            }
            ArrayList<Integer> missingAtmsB = new ArrayList<Integer>();
            for (int i=0; i<szB; i++)
            {
                if (!bestCombination.values().contains(i))
                {
                    missingAtmsB.add(i);
                }
            }

//TODO remove this block
if (smallA)
{
    for (int i=0; i<missingAtmsA.size(); i++)
    {
        bestCombination.put(missingAtmsA.get(i),missingAtmsB.get(i));
    }
}
//end of block to remove


            //TODO
            System.out.println("TODO permutations of unmapped atoms");
//System.exit(-1);
        }


/*
            List<Integer> idsFragsA = new ArrayList<Integer>();
            List<Integer> idsFragsB = new ArrayList<Integer>();

            for (int i=0; i< fragsA.size(); i++)
            {
                idsFragsA.add(i);
            }
            for (int i=0; i< fragsB.size(); i++)
            {
                idsFragsB.add(i);
            }
            Collection<List<Integer>> permsA =
                                           Collections2.permutations(idsFragsA);
            Collection<List<Integer>> permsB =
                                           Collections2.permutations(idsFragsB);

            int iPerm = 0;
            for (List<Integer> pA : permsA)
            {
                for (List<Integer> pB : permsB)
                {
                    iPerm++;
                    System.out.println("Permutation: "+iPerm);
                    System.out.println(" "+pA+" "+pB);
                }
            }
            compareGeometryBySuperposition((IAtomContainer) molA.clone(),
                                           (IAtomContainer) molB.clone());

        }
        catch (Throwable t)
        {
            t.printStackTrace();
            IOtools.writeSDFAppend("AutoCompChem-error_uncloneable.sdf",molA,false);
            IOtools.writeSDFAppend("AutoCompChem-error_uncloneable.sdf",molB,true);
            Terminator.withMsgAndStatus("ERROR! Cannot clone mols to calculate "
                + "best atom mapping.", -1);
        }
*/

//TODO change
        return bestCombination;
    }

//------------------------------------------------------------------------------

}
