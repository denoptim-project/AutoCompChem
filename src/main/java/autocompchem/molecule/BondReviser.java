package autocompchem.molecule;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

/*
 *   Copyright (C) 2014  Marco Foscato
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.List;
import java.util.Map;

import org.openscience.cdk.interfaces.IAtomContainer;
import org.openscience.cdk.interfaces.IBond;

import autocompchem.datacollections.ParameterStorage;
import autocompchem.files.FileUtils;
import autocompchem.io.IOtools;
import autocompchem.io.SDFIterator;
import autocompchem.run.Terminator;
import autocompchem.smarts.ManySMARTSQuery;
import autocompchem.smarts.MatchingIdxs;

/**
 * Tool for editing existing bonds in a molecular object. 
 * Parameters needed by the BondReviser are:
 * <ul>
 * <li> 
 * <b>INFILE</b> path or name of the SDF file containing the structure
 *            (only SDF files with ONE molecule are acceptable!)
 * </li>
 * <li>
 * <b>OUTFILE</b>  path or name of the SDF file that will contain the results
 * </li>
 * <li>
 * <b>SMARTS</b> list of SMARTS (strings blank space separated) defining
 * the bonds to be modified. The form of the string has to be
 * capable of matching the pair of atoms connected by the target 
 * bond. For instance, [#8]-@[#7] and [$(c-OC)]~[n].
 * </li>
 * <li>
 * <b>VERBOSITY</b>  verbosity level
 * </li>
 * </ul>
 * Other optional parameters are:
 * <ul>
 * <li>
 * <b>NEWBO</b> new bond order to be assigned to the target bond.
 * Permitted values are as <code>IBond.Order</code>.
 * <br>
 * <b>WARNING!</b> Pretending too much (i.e., trying to set a QUADRUPLE bond 
 *            between C and N) is likely to generate problems like the output
 *            not being written!
 * </li>
 * </ul>
 * 
 * @author Marco Foscato
 */

//TODO-gg to worker?

public class BondReviser
{

    //Filenames
    private File inFile;
    private File outFile;

    //List (with string identifier) of smarts
    private Map<String,String> smarts = new HashMap<String,String>();

    //Bond related properties
    private String newBO = "";

    //Verbosity level
    private int verbosity = 1;

//------------------------------------------------------------------------------

    /**
     * Constructor for an empty BondReviser
     */

    public BondReviser() 
    {}

//------------------------------------------------------------------------------

    /**
     * Constructs a BondReviser specifying the parameters taken from 
     * formatted file or generated by other tools.
     * All the parameters must be in the form specified as follows:
     * <ul>
     * <li> 
     * <b>INFILE</b> path or name of the SDF file containing the structure
     *            (only SDF files with ONE molecule are acceptable!)
     * </li>
     * <li>
     * <b>OUTFILE</b>  path or name of the SDF file that will contain the results
     * </li>
     * <li>
     * <b>SMARTS</b> list of SMARTS (strings blank space separated) defining
     * the bonds to be modified. The form of the string has to be
     * capable of matching the pair of atoms connected by the target 
     * bond. For instance, [#8]-@[#7] and [$(c-OC)]~[n].
     * </li>
     * <li>
     * <b>VERBOSITY</b>  verbosity level
     * </li>
     * </ul>
     * Other optional parameters are:
     * <ul>
     * <li>
     * <b>NEWBO</b> new bond order to be assigned to the target bond.
     * Permitted values are as <code>IBond.Order</code>.
     * <br>
     * <b>WARNING!</b> Pretending too much (i.e., trying to set a QUADRUPLE bond 
     *            between C and N) is likely to generate problems like the output
     *            not being written!
     * </li>
     * </ul>
     * 
     * @param params object <code>ParameterStorage</code> containing all the
     * parameters needed
     */

    public BondReviser(ParameterStorage params) 
    {
        //Define verbosity
        String vStr = params.getParameter("VERBOSITY").getValue().toString();
        this.verbosity = Integer.parseInt(vStr);

        if (verbosity > 0)
            System.out.println(" Adding parameters to BondReviser");


        //Get and check the input file (which has to be an SDF file)
        this.inFile = new File(
        		params.getParameter("INFILE").getValue().toString());
        FileUtils.foundAndPermissions(this.inFile,true,false,false);

        //Get and check output file
        this.outFile = new File(
        		params.getParameter("OUTFILE").getValue().toString());
        FileUtils.mustNotExist(this.outFile);

        //Get the list of SMARTS to be matched
        String allSamrts = 
                params.getParameter("SMARTS").getValue().toString();
        if (verbosity > 0)
        {
            System.out.println(" Importing SMARTS queries ");
        }
        String[] parts = allSamrts.split("\\s+");
        for (int i=0; i<parts.length; i++)
        {
            String singleSmarts = parts[i];
            if (singleSmarts.equals(""))
                continue;
            this.smarts.put(Integer.toString(i),singleSmarts);
        }

        //Get New properties (optional parameters)
        if (params.contains("NEWBO"))
        {
            this.newBO = params.getParameter("NEWBO").getValue().toString();
        }
    }

//------------------------------------------------------------------------------

    /**
     * Constructs a new BondReviser specifying the name 
     * (or path) of the input SDF file and the list of SMARTS to match
     * @param file the input (i.e. name.sdf)
     * @param smarts list of SMARTS as strings blank space separated
     * @param verbosity verbosity level
     */

    public BondReviser(File file, Map<String,String> smarts, int verbosity)
    {
        this.inFile = file;
        this.smarts = smarts;
        this.verbosity = verbosity;
    }

//------------------------------------------------------------------------------

    /**
     * Constructs a new BondReviser specifying the name 
     * (or path) of the input SDF file and the list of SMARTS to match
     * @param file the input (i.e. name.sdf)
     * @param smarts list of SMARTS as strings blank space separated
     * @param verbosity verbosity level
     * @param newBO new bond order for the target bonds
     */

    public BondReviser(File file, Map<String,String> smarts, 
                                                int verbosity, String newBO)
    {
        this.inFile = file;
        this.smarts = smarts; 
        this.newBO = newBO;
        this.verbosity = verbosity;
    }

//------------------------------------------------------------------------------

    /**
     * Identify the target bonds and modify their properties according to the 
     * setting given to the constructor.
     */

    public void reviseBonds()
    {
        int n = 0;
        try {
            SDFIterator sdfItr = new SDFIterator(inFile);
            while (sdfItr.hasNext())
            {
                //Get the molecule
                n++;
                IAtomContainer mol = sdfItr.next();
                String molName = MolecularUtils.getNameOrID(mol);

                if (verbosity > 1)
                    System.out.println(" Reading molecule (" + n + "): " 
                                                             + molName);

                //Get target bonds
                ManySMARTSQuery msq = new ManySMARTSQuery(mol,smarts,verbosity);
                if (msq.hasProblems())
                {
                    String cause = msq.getMessage();
                    Terminator.withMsgAndStatus("ERROR! " +cause,-1);
                }

                ArrayList<IBond> targets = new ArrayList<IBond>();
                for (String key : smarts.keySet())
                {
                    if (msq.getNumMatchesOfQuery(key) == 0)
                        {
                        continue;
                    }
                    
                    MatchingIdxs allMatches =  msq.getMatchingIdxsOfSMARTS(key);
                    for (List<Integer> innerList : allMatches)
                    {
                        if (innerList.size() != 2)
                        {
                            if (verbosity > 0)
                            {
                                System.out.println("WARNING! Query '" + key 
                                + "' matched a number of atoms not equal to "
                                + "two. Match " + innerList + " ignored!");
                            }
                            continue;
                        }

                        IBond targetBond = mol.getBond(
                                                mol.getAtom(innerList.get(0)),
                                                mol.getAtom(innerList.get(1)));

                        targets.add(targetBond);
                    }
                }

                //Modify target bonds
                for (IBond bnd : targets)
                {
                    if (!newBO.equals("") && newBO != null)
                    {
                        String defBO = "SINGLE";
                        IBond.Order bo = IBond.Order.valueOf(defBO);
                        try {
                            bo = IBond.Order.valueOf(newBO);
                            if (verbosity > 1)
                            {
                                System.out.println("Setting bond order of bond "
                                + MolecularUtils.getAtomRef(bnd.getAtom(0),mol)
                                 + "-" 
                                + MolecularUtils.getAtomRef(bnd.getAtom(1),mol)
                                + " to '"
                                + newBO + "'.");
                            }
                        } catch (Throwable t) {
                            System.out.println("WARNING! Unable to "
                                + "deal with the given bond order '" 
                                + newBO + "'. Check CDK's API at page "
                                + "IBond.Order to find the acceptable "
                                + "list of Enum constants.");
                            System.out.println("Setting bond order of bond "
                                + MolecularUtils.getAtomRef(bnd.getAtom(0),mol)
                                + "-" 
                                + MolecularUtils.getAtomRef(bnd.getAtom(1),mol)
                                + " to '"
                                + defBO + "'.");
                        }
                        bnd.setOrder(bo);
                    }

//
//TODO: add here the modification of other bond properties
//
                }

                //Store resulting molecule
                IOtools.writeSDFAppend(outFile,mol,true);

            } //end loop over molecules
            sdfItr.close();
        } catch (Throwable t) {
            Terminator.withMsgAndStatus("ERROR! Exception returned by "
                + "SDFIterator while reading " + inFile, -1);
        }
    }

//-----------------------------------------------------------------------------

}
