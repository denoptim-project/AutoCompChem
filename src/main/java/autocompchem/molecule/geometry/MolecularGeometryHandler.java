package autocompchem.molecule.geometry;

import java.util.ArrayList;

/*   
 *   Copyright (C) 2016  Marco Foscato 
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.lang3.EnumUtils;
import org.openscience.cdk.interfaces.IAtomContainer;

import autocompchem.datacollections.NamedData;
import autocompchem.datacollections.NamedData.NamedDataType;
import autocompchem.datacollections.ParameterStorage;
import autocompchem.modeling.AtomLabelsGenerator;
import autocompchem.modeling.constraints.ConstraintsGenerator;
import autocompchem.modeling.constraints.ConstraintsSet;
import autocompchem.molecule.AtomContainerInputProcessor;
import autocompchem.molecule.MolecularUtils;
import autocompchem.molecule.intcoords.zmatrix.ZMatrix;
import autocompchem.molecule.intcoords.zmatrix.ZMatrixConstants;
import autocompchem.molecule.intcoords.zmatrix.ZMatrixHandler;
import autocompchem.run.Job;
import autocompchem.run.Terminator;
import autocompchem.wiro.chem.ChemSoftConstants;
import autocompchem.wiro.chem.ChemSoftConstants.CoordsType;
import autocompchem.worker.Task;
import autocompchem.worker.Worker;
import autocompchem.worker.WorkerConstants;
import autocompchem.worker.WorkerFactory;


/**
 * Tool to handle molecular geometry representations.
 * 
 * @author Marco Foscato
 */

public class MolecularGeometryHandler extends AtomContainerInputProcessor
{
    
    /**
     * Type of coordinate representation
     */
    private CoordsType coordsType = CoordsType.XYZ;
    
    /**
     * Flag requesting the use of atom tags, i.e., a string to be used 
     * instead of the bare elemental symbol to identify an atom. Tags are unique
     * within a chemical object and can be anything that is generated by
     * {@link AtomLabelsGenerator}.
     */
    private boolean useAtomTags = false;

    /**
     * String defining the task of generating the definition of a geometry
     */
    public static final String GETMOLECULARGEOMETRYTASKNAME = 
    		"getMolecularGeometry";

    /**
     * Task about generating the definition of the geometry
     */
    public static final Task GETMOLECULARGEOMETRYTASK;
    static {
    	GETMOLECULARGEOMETRYTASK = Task.make(GETMOLECULARGEOMETRYTASKNAME);
    }
    
    /**
     * String defining the task of getting the identifier of the geometry
     */
    public static final String GETMOLECULENAMETASKNAME = 
    		"getMoleculeName";

    /**
     * Task about getting the identifier of the geometry
     */
    public static final Task GETMOLECULENAMETASK;
    static {
    	GETMOLECULENAMETASK = Task.make(GETMOLECULENAMETASKNAME);
    }

//-----------------------------------------------------------------------------
	
    /**
     * Constructor.
     */
    public MolecularGeometryHandler()
    {}
    
//------------------------------------------------------------------------------

    @Override
    public Set<Task> getCapabilities() {
        return Collections.unmodifiableSet(new HashSet<Task>(
             Arrays.asList(GETMOLECULARGEOMETRYTASK, GETMOLECULENAMETASK)));
    }

//------------------------------------------------------------------------------

    @Override
    public String getKnownInputDefinition() {
        return "inputdefinition/MolecularGeometryHandler.json";
    }

//------------------------------------------------------------------------------

    @Override
    public Worker makeInstance(Job job) {
        return new MolecularGeometryHandler();
    }
    
//-----------------------------------------------------------------------------

    /**
     * Initialize the worker according to the parameters loaded by constructor.
     */

	@Override
    public void initialize()
    {
		super.initialize();
		
        if (params.contains(ChemSoftConstants.PARCOORDTYPE))
        {
        	coordsType = EnumUtils.getEnumIgnoreCase(CoordsType.class,
        			params.getParameter(ChemSoftConstants.PARCOORDTYPE)
        			.getValueAsString());
        }
        
        if (params.contains(ChemSoftConstants.PARATMLABELTYPE))
        {
        	useAtomTags = true;
        }
    }
    
//-----------------------------------------------------------------------------

    /**
     * Performs any of the registered tasks according to how this worker
     * has been initialised.
     */

    @Override
    public void performTask()
    {
    	processInput();
    }
    
//------------------------------------------------------------------------------

	@Override
	public void processOneAtomContainer(IAtomContainer iac, int i) 
	{
		if (task.equals(GETMOLECULARGEOMETRYTASK))
    	{
			Object output = null;
			IAtomContainer iacPossiblyLabelled = iac;
			
			if (useAtomTags)
			{
				ParameterStorage labelsParams = params.clone();
				labelsParams.setParameter(WorkerConstants.PARTASK, 
	    				AtomLabelsGenerator.GENERATEATOMLABELSTASK.ID);
				labelsParams.setParameter(ChemSoftConstants.PARGEOM,
	    				NamedDataType.IATOMCONTAINER, 
	    				new ArrayList<IAtomContainer>(Arrays.asList(iac)));
				AtomLabelsGenerator labGenerator = null;
				try {
					labGenerator = (AtomLabelsGenerator) 
		    			WorkerFactory.createWorker(labelsParams, myJob);
				} catch (Throwable t) {
					//Cannot happen!
					t.printStackTrace();
				}
				List<String> atomTags = labGenerator.generateAtomLabels(iac);
				iacPossiblyLabelled = MolecularUtils.makeSimpleCopyWithAtomTags(
						iac, 
						atomTags);
			}
			
			switch (coordsType)
	    	{    
	        	case ZMAT:
	        	{
	        		ParameterStorage zmatMakerTask = params.clone();
	        		zmatMakerTask.setParameter(WorkerConstants.PARTASK, 
	        				ZMatrixHandler.CONVERTTOZMATTASK.ID);
	                Worker w = null;
					try {
						w = WorkerFactory.createWorker(zmatMakerTask,myJob);
					} catch (ClassNotFoundException e1) {
						//Cannot happen!
						e1.printStackTrace();
					}
	                ZMatrixHandler zmh = (ZMatrixHandler) w;
	                ZMatrix zmat = zmh.makeZMatrix(iacPossiblyLabelled);
	                
	                if (params.contains(ZMatrixConstants.SELECTORMODE))
	                {
	                	ParameterStorage cnstMakerTask = params.clone();
	                	cnstMakerTask.setParameter(WorkerConstants.PARTASK, 
	                			ConstraintsGenerator.GENERATECONSTRAINTSTASK.ID);
	
	                    ConstraintsGenerator cnstrg = null;
						try {
							cnstrg = (ConstraintsGenerator)
									WorkerFactory.createWorker(cnstMakerTask, 
											myJob);
						} catch (ClassNotFoundException e1) {
							//Cannot happen!
							e1.printStackTrace();
						}
	                	ConstraintsSet cs = new ConstraintsSet();
	                	try {
	    					cs = cnstrg.createConstraints(iac);
	    				} catch (Exception e) {
	    					e.printStackTrace();
	    					Terminator.withMsgAndStatus("ERROR! "
	    							+ "Unable to create constraints. "
	    							+ "Exception from the "
	    							+ ConstraintsGenerator.class.getSimpleName() 
	    							+ ".", -1);
	    				}
	                	String mode = params.getParameterValue(
	                			ZMatrixConstants.SELECTORMODE);
	                	switch (mode.toUpperCase())
	                	{
	                	case ZMatrixConstants.SELECTORMODE_CONSTANT:
	                    	zmat.setConstants(cs);
	                		break;
	
	                	case ZMatrixConstants.SELECTORMODE_VARIABLES:
	                    	zmat.setVariables(cs);
	                		break;
	                	}
	                }
	                
	                output = zmat;
	        		break;
	        	}
	        	
	        	case XYZ:
	        	default:
	        	{
	        		output = iacPossiblyLabelled;
	        		break;
	        	}
	    	}
			
			if (exposedOutputCollector != null)
	    	{
				exposeOutputData(new NamedData(task.ID+"mol-"+i, output));
	    	}
    	} else if (task.equals(GETMOLECULENAMETASK)) {
    		String name = MolecularUtils.getNameOrID(iac, "mol-"+i);
			if (exposedOutputCollector != null)
	    	{
				exposeOutputData(new NamedData(task.ID+"mol-"+i, name));
	    	}
    	} else {
    		dealWithTaskMismatch();
        }
	}
    
//-----------------------------------------------------------------------------

}
