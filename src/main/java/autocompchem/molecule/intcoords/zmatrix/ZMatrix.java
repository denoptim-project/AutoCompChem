package autocompchem.molecule.intcoords.zmatrix;

/*
 *   Copyright (C) 2016  Marco Foscato
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU Affero General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU Affero General Public License for more details.
 *
 *   You should have received a copy of the GNU Affero General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import autocompchem.modeling.constraints.ConstraintsSet;
import autocompchem.run.Terminator;

/**
 * Object representing a Z-matrix: an internal coordinates representation of a 
 * geometry.
 *
 * @author Marco Foscato
 */ 

public class ZMatrix implements Cloneable
{
    /**
     * Title/name (optional).
     */
    private String title = "notitle";

    /**
     * List of centers defined by internal coordinates.
     */
    private ArrayList<ZMatrixAtom> zatoms;

    /**
     * List of 1-2 relations not corresponding to formal bonds.
     */
    private ArrayList<int[]> delBondPointers;

    /**
     * List of bonded atoms not defined by 1-2 relations.
     */
    private ArrayList<int[]> addBondPointers; 

    /**
     * Flag recording enumeration formalism: <code>true</code> for 0-based.
     */
//TODO
/*
    private = true;
*/
    
    /**
     * Flag recording the presence of bonds not mapped by internal coordinates.
     */
    private boolean hasBondsToAdd = false;

    /**
     * Flag recording the presence of internal coordinates not corresponding to
     * actual bonds.
     */
    private boolean hasBondsToDel = false;

//------------------------------------------------------------------------------

    /**
     * Construct an empty ZMatrix.
     */

    public ZMatrix()
    {
        zatoms = new ArrayList<ZMatrixAtom>();
        delBondPointers = new ArrayList<int[]>();
        addBondPointers = new ArrayList<int[]>();
    }

//------------------------------------------------------------------------------
  
    /**
     * Constructs a ZMatrix with internal coordinates taken from lines of text.
     * @param lines the text lines to read in. We assume the format is 
     * consistent with what generated by method {@link #toLinesOfText}.
     * That is, each line must be a string representation of a 
     * {@link ZMatrixAtom}.
     */

    public ZMatrix(ArrayList<String> lines)
    {
        // First need to decide whether the input used 0- or 1-based atom IDs
        boolean zeroBasedIDs = false;
        int idBase = 0;
        Pattern p = Pattern.compile("\\s0\\s");
        for (String line : lines)
        {
            String sStr = line.trim();
            if (sStr.endsWith("0"))
            {
                sStr = sStr.substring(0,sStr.length() - 1);
            }
            if (sStr.startsWith("0"))
            {
                sStr = sStr.substring(1);
            }
            Matcher m = p.matcher(sStr);
            if (m.find())
            {
                idBase = -1;
                zeroBasedIDs = true;
                break;
            }
        }
        // Now, read in the ZMatrix
        zatoms = new ArrayList<ZMatrixAtom>();
        for (String line : lines)
        {
            idBase++;
            try
            {
                ZMatrixAtom atm = new ZMatrixAtom(line,idBase,zeroBasedIDs);
                zatoms.add(atm);
            }
            catch (Throwable t)
            {
                t.printStackTrace();
                Terminator.withMsgAndStatus("Could not import '" + line + "' "
                        + "in a ZMatrix.",-1);
            }
        }
    }

//------------------------------------------------------------------------------

    /**
     * Returns the number of centers (i.e., atoms) in the ZMatrix.
     * @return the number of centers.
     */

    public int getZAtomCount()
    {
        return this.zatoms.size();
    }

//------------------------------------------------------------------------------

    /**
     * Returns the atom with the given index in the ZMatrix (0-based index).
     * @param i index.
     * @return the atom in position i.
     */

    public ZMatrixAtom getZAtom(int i)
    {
        return this.zatoms.get(i);
    }

//------------------------------------------------------------------------------

    /**
     * Append the coordinates of a new atom/center.
     * @param atm atom to add to the ZMatrix.
     */

    public void addZMatrixAtom(ZMatrixAtom atm)
    {
        zatoms.add(atm);
    }


//------------------------------------------------------------------------------

    /**
     * Append the pointer to a 1-2 relation not corresponding to a bond
     * @param ia index of first partner of 1-2 relation
     * @param ib index of second partner of 1-2 relation
     */
        
    public void addPointerToNonBonded(int ia, int ib)
    {
        hasBondsToDel = true;
        delBondPointers.add(new int[] {ia,ib});
    }

//------------------------------------------------------------------------------

    /**
     * Return the pointers to pairs of atoms that share an internal coordinate
     * defining the interatomic distance, but are not bonded.
     * @return the list of pointers to pairs of atoms
     */
 
    public ArrayList<int[]> getPointersToNonBonded()
    {
        return delBondPointers;
    }

//------------------------------------------------------------------------------

    /**
     * Append the pointer to a bond not represented by any 1-2 relation
     * @param ia index of first partner of 1-2 relation
     * @param ib index of second partner of 1-2 relation
     */

    public void addPointerToBonded(int ia, int ib)
    {
        hasBondsToAdd = true;
        addBondPointers.add(new int[] {ia,ib});
    }

//------------------------------------------------------------------------------

    /**
     * Return the pointers to pairs of atoms that share a bond but have no
     * internal coordinate defining their distance.
     * @return the list of pointers to bonded pairs of atoms.
     */

    public ArrayList<int[]> getPointersToBonded()
    {
        return addBondPointers;
    }

//-----------------------------------------------------------------------------

    /**
     * @return <code>true</code> if there are bonds that are not mapped by any
     * internal coordinate
     */
   
    public boolean hasAddedBonds()
    {
        return hasBondsToAdd;
    }

//-----------------------------------------------------------------------------

    /**
     * @return <code>true</code> if there are internal coordinates that do not
     * correspond to actual bonds
     */

    public boolean hasBondsToDelete()
    {
        return hasBondsToDel;
    }

//-----------------------------------------------------------------------------

    /**
     * Set the title
     * @param title the new title
     */

    public void setTitle(String title)
    {
        this.title = title;
    }

//-----------------------------------------------------------------------------

    /**
     * Get the title
     * @return the title
     */

    public String getTitle()
    {
        return title;
    }

//-----------------------------------------------------------------------------

    /**
     * Evaluates if this z-matrix contains any atom of which the internal
     * coordinates include the torsion angle corresponding
     * to the rotation along the bond/axes defined by two given centers.
     * @param idI index of the first center defining the target bond/axes
     * @param idJ index of the second center defining the target bond/axes.
     * @return <code>true</code> if the torsion is found in the z-matrix
     */

    public boolean findTorsion(int idI, int idJ)
    {
        boolean res = false;
        for (ZMatrixAtom zatm : zatoms)
        {
            if (zatm.usesTorsion(idI,idJ))
            {
                res = true;
                break;
            }
        }
        return res;
    }

//------------------------------------------------------------------------------

    /**
     * Prints the ZMatrix as a list of lines.
     * @param useReferences if <code>true</code> makes the method write variable
     * names, otherwise the numerical value of each variable is reported.
     * @param zeroBasedIds set to <code>true</code> to require zero-based 
     * numbering
     * @return the list of lines of text as a list of strings
     */

    public ArrayList<String> toLinesOfText(boolean useReferences, 
                                                           boolean zeroBasedIds)
    {
        ArrayList<String> lines = new ArrayList<String>();
        for (ZMatrixAtom atm : zatoms)
        {
            lines.add(atm.toZMatrixLine(useReferences,zeroBasedIds));
        }        
        return lines;
    }

//------------------------------------------------------------------------------

    /**
     * @returns a deep copy of this ZMatrix
     */
    
    @Override
    public ZMatrix clone()
    {
    	ZMatrix c = new ZMatrix();
    	c.setTitle(title);
    	for (ZMatrixAtom zatm : zatoms)
    	{
    		c.addZMatrixAtom(zatm.clone());
    	}
    	for (int[] pair : addBondPointers)
    	{
    		c.addPointerToBonded(pair[0], pair[1]);
    	}
    	for (int[] pair : delBondPointers)
    	{
    		c.addPointerToNonBonded(pair[0], pair[1]);
    	}
    	return c;
    }
    
//------------------------------------------------------------------------------

  	@Override
  	public boolean equals(Object o)
  	{
  		if (!(o instanceof ZMatrix))
  			return false;
  		ZMatrix other = (ZMatrix) o;
  		
  		if (this.title!=null && other.title!=null
  				&& !this.title.equals(other.title))
  			return false;
  		if (this.title==null && other.title!=null)
  			return false;
  		if (this.title!=null && other.title==null)
  			return false;
  		
  		if (this.zatoms.size() != other.zatoms.size())
  			return false;
  		for (int i=0; i<this.zatoms.size(); i++)
    	{
    		if (!this.zatoms.get(i).equals(other.zatoms.get(i)))
    			return false;
    	}
  		
  		if (this.addBondPointers.size() != other.addBondPointers.size())
  			return false;
  		for (int i=0; i<this.addBondPointers.size(); i++)
    	{
    		if (this.addBondPointers.get(0)[0]!=other.addBondPointers.get(0)[0])
    			return false;
    		if (this.addBondPointers.get(0)[1]!=other.addBondPointers.get(0)[1])
    			return false;
    	}
  		
  		if (this.delBondPointers.size() != other.delBondPointers.size())
  			return false;
  		for (int i=0; i<this.delBondPointers.size(); i++)
    	{
    		if (this.delBondPointers.get(0)[0]!=other.delBondPointers.get(0)[0])
    			return false;
    		if (this.delBondPointers.get(0)[1]!=other.delBondPointers.get(0)[1])
    			return false;
    	}
  		
  		if (this.hasBondsToAdd && !other.hasBondsToAdd)
  			return false;
  		if (!this.hasBondsToAdd && other.hasBondsToAdd)
  			return false;
  		
  		if (this.hasBondsToDel && !other.hasBondsToDel)
  			return false;
  		if (!this.hasBondsToDel && other.hasBondsToDel)
  			return false;
  		
  	   	return true;
  	}
  	
//------------------------------------------------------------------------------
  	
  	/**
  	 * Sets constant any of the internal coordinates defined in the given set.
  	 * Ignores any internal coordinate that is not used in this ZMatrix, 
  	 * but is present in the given set. Any internal coordinate present in this
  	 * ZMatrix and not found in the given set will be set to be a variable.
  	 * @param cs the collection of internal coordinates to be set as constant, 
  	 * if present in this ZMatrix.
  	 */
	public void setConstants(ConstraintsSet cs) 
	{
		setVariableOrConstants(cs, true);
	}
    
//------------------------------------------------------------------------------

	/**
  	 * Sets non-constant any of the internal coordinates defined in the given set.
  	 * Ignores any internal coordinate that is not used in this ZMatrix, 
  	 * but is present in the given set. Any internal coordinate present in this
  	 * ZMatrix and not found in the given set will be set to be constant.
  	 * @param cs the collection of internal coordinates to be set as variable, 
  	 * if present in this ZMatrix.
  	 */
	public void setVariables(ConstraintsSet cs) 
	{
		setVariableOrConstants(cs, false);
	}
	
//------------------------------------------------------------------------------
  	
  	/**
  	 * Sets constant/variables any of the internal coordinates defined in the 
  	 * given set.
  	 * Ignores any internal coordinate that is not used in this ZMatrix, 
  	 * but is present in the given set. Any internal coordinate present in this
  	 * ZMatrix and not found in the given set will be set to be a 
  	 * variable/constant.
  	 * @param cs the collection of internal coordinates to be set as constant
  	 * or variable, 
  	 * if present in this ZMatrix.
  	 * @param asConstant use <code>true</code> to flag matched internal
  	 * coordinates as constants and flag all the others variable. 
  	 * Use <code>false</code> to flag matched internal
  	 * coordinates as variables and flag all the others constant. 
  	 */
	private void setVariableOrConstants(ConstraintsSet cs, boolean asConstant) 
	{
		for (ZMatrixAtom zma : zatoms)
		{
			if (zma.icI != null)
			{
				if (asConstant)
				{
					zma.icI.setAsConstant(cs.containsInternalCoord(zma.icI));
				} else {
					zma.icI.setAsConstant(!cs.containsInternalCoord(zma.icI));
				}
				
				if (zma.icJ != null)
				{
					if (asConstant)
					{
						zma.icJ.setAsConstant(cs.containsInternalCoord(
								zma.icJ));
					} else {
						zma.icJ.setAsConstant(!cs.containsInternalCoord(
								zma.icJ));
					}
					if (zma.icK != null)
					{
						if (asConstant)
						{
							zma.icK.setAsConstant(cs.containsInternalCoord(
									zma.icK));
						} else {
							zma.icK.setAsConstant(!cs.containsInternalCoord(
									zma.icK));
						}
					}
				}
			}
		}
	}

//------------------------------------------------------------------------------

	/**
	 * @return <code>true</code> if this ZMatrix contains any internal 
	 * coordinate that is flagged as constant.
	 */
	public boolean hasConstants() 
	{
		for (ZMatrixAtom zatm : zatoms)
		{
			if (zatm.hasConstantIC())
				return true;
		}
		return false;
	}
    
//------------------------------------------------------------------------------

}
