package autocompchem.run.jobediting;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openscience.cdk.AtomContainerSet;
import org.openscience.cdk.interfaces.IAtomContainer;

import com.google.common.io.Files;

import autocompchem.datacollections.NamedData.NamedDataType;
import autocompchem.files.FileUtils;
import autocompchem.chemsoftware.ChemSoftConstants;
import autocompchem.datacollections.NamedDataCollector;
import autocompchem.perception.circumstance.Circumstance;
import autocompchem.perception.circumstance.ICircumstance;
import autocompchem.perception.infochannel.InfoChannel;
import autocompchem.perception.infochannel.InfoChannelType;
import autocompchem.perception.situation.Situation;
import autocompchem.run.Job;
import autocompchem.run.JobEvaluator;
import autocompchem.run.MonitoringJob;
import autocompchem.run.Terminator;
import autocompchem.run.jobediting.Action.ActionType;
import autocompchem.run.jobediting.DataArchivingRule.Type;
import autocompchem.utils.SetUtils;
import autocompchem.utils.StringUtils;

/**
 * 
 */
public class ActionApplier 
{
    
//------------------------------------------------------------------------------
    
    public static List<IAtomContainer> getRestartGeoms(Action action, 
    		Job trigger)
    {
    	@SuppressWarnings("unchecked")
		Map<Integer, NamedDataCollector> jobOutputData = 
    			(Map<Integer, NamedDataCollector>) trigger.exposedOutput
    			.getNamedData(ChemSoftConstants.JOBOUTPUTDATA).getValue();
    	
    	int focusJobStepID = (int) trigger.exposedOutput.getNamedData(
    			JobEvaluator.NUMSTEPSKEY).getValue();
    	
    	NamedDataCollector stepData = jobOutputData.get(focusJobStepID);
    	AtomContainerSet acs = (AtomContainerSet) stepData
				.getNamedData(ChemSoftConstants.JOBDATAGEOMETRIES)
				.getValue();
    	
    	List<IAtomContainer> iacs = new ArrayList<IAtomContainer>();
    	
    	//TODO-gg modify to take any other than the last geometry found
    	// according to indication from action
    	iacs.add(acs.getAtomContainer(acs.getAtomContainerCount()-1));
    	
    	return iacs;
    }
	
//------------------------------------------------------------------------------

    /**
     * Performs the action that has been 
     * requested as a response to
     * a notification from a job (i.e., the trigger) and that affect one or more
     * jobs in the given list.
     * 
     * Note that any action is expected to be molecule-agnostic, so any change 
     * on job features that are dependent on the identify of the chemical system
     *  should not be done here.
	 * @param action The action requested by the trigger.
	 * @param trigger The job that triggered the request for action.
	 * @param todoJobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 */
    public static void performAction(Action action, 
    		Job trigger, List<Job> todoJobs, int restartCounter)
    {
    	Job focusJob = (Job) trigger.exposedOutput.getNamedData(
    			JobEvaluator.EVALUATEDJOB).getValue();
    	int focusJobStepID = (int) trigger.exposedOutput.getNamedData(
    			JobEvaluator.NUMSTEPSKEY).getValue();
    	
    	performAction(action, focusJob, focusJobStepID, todoJobs, 
    			restartCounter);
    }
	
//------------------------------------------------------------------------------

    /**
     * Performs the action that has been 
     * requested as a response to
     * a notification from a job (i.e., the trigger) and that affect one or more
     * jobs in the given list. 
     * Note that any action is expected to be molecule-agnostic, so any change 
     * on job features that are dependent on the identify of the chemical system
     *  should not be done here.
     * 
	 * @param action The action requested by the trigger.
	 * @param focusJob The job that failed or caused the triggering of the 
	 * action.
	 * @param focusJobStepId the index of the focus job in its list of steps.
	 * @param todoJobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 */
    static void performAction(Action action, Job focusJob, int focusJobStepId, 
    		List<Job> todoJobs, int restartCounter)
    {
    	ActionType aType = action.getType();
    	
    	// No need to archive or edit if the reaction is just to stop.
    	if (aType==ActionType.STOP)
    		return;
    	
    	// Create copy of previous data from jobs
    	archivePreviousResults(todoJobs, restartCounter, 
    			action.getFilenamePatterns(Type.COPY), 
    			action.getFilenamePatterns(Type.MOVE), 
    			action.getFilenamePatterns(Type.DELETE));
    	
    	// Trim job steps to have as first step the failing step
    	if (aType==ActionType.REDO && focusJobStepId>0 
    			&& focusJob.getNumberOfSteps()>0)
    	{
    		for (int i=0; i<focusJobStepId; i++)
    			focusJob.getSteps().remove(0);
    	}
    	
    	Job orinallyFailingStep = null;
    	if (focusJob.getNumberOfSteps()>0)
    	{
    		orinallyFailingStep = focusJob.getStep(0);
    	} else {
    		orinallyFailingStep = focusJob;
    	}

    	// Pre-pend (i.e., append in front) any step that should be appended
    	for (int i=(action.preliminarySteps.size()-1); i>-1; i--)
    	{
    		Job preliminaryStep = action.preliminarySteps.get(i);
    		for (IJobEditingTask jet : action.inheritedSettings)
    		{
    			//TODO-gg recover and generalize
    			//jet.inheritSettings(orinallyFailingStep, preliminaryStep);
    		}
    		focusJob.getSteps().add(0, preliminaryStep);
    	}
    	
    	// Modify job settings
    	for (IJobEditingTask jet : action.jobEditTasks)
    	{
    		jet.applyChange(focusJob);
    	}
    	
    	// NB: any data that may be needed to restart of fix things should be 
    	// taken and used before resetting the jobs.
    	
    	// Reset status of all jobs to re-run them.
    	for (Job job : todoJobs)
    	{
    		job.resetRunStatus();
    	}
    }
    
//------------------------------------------------------------------------------
    
    /**
     * Moves files related to the given jobs into dedicated archive sub-folders
     * named after the <code>restartCounter</code>.
     * @param jobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 * @param fileNamePatternToCopy pattern that identifies files that, 
	 * if present, should be copied instead of moved to the archive as they are 
	 * needed to restart the jobs.The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the the last component of 
	 * the pathname.
	 * @param fileNamePatternToArchive pattern identifying files to move into 
	 * the archive. The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the the last component of 
	 * the pathname.
	 * @param fileNamePatternToTrash pattern identifying files to remove without
	 * keeping a copy. The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the last component of 
	 * the pathname.
     */
    static void archivePreviousResults(List<Job> jobs, int restartCounter,
    		Set<String> fileNamePatternToCopy, 
    		Set<String> fileNamePatternToArchive,
    		Set<String> fileNamePatternToTrash)
    {
		for (Job j : jobs)
		{
			if (j instanceof MonitoringJob)
				continue;
			
			archivePreviousResults(j, restartCounter, fileNamePatternToCopy,
					fileNamePatternToArchive, fileNamePatternToTrash);
		}
    }
 
//------------------------------------------------------------------------------
    
    /**
     * Moves files related to the given job into dedicated archive sub-folders
     * named after the <code>restartCounter</code>.
     * @param job the job that may be altered by the action. It should not be 
     * running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the job that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 * @param fileNamePatternToCopy pattern that identifies files that, 
	 * if present, should be copied instead of moved to the archive as they are 
	 * needed to restart the jobs.The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the the last component of 
	 * the pathname.
	 * @param fileNamePatternToArchive pattern identifying files to move into 
	 * the archive. The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the the last component of 
	 * the pathname.
	 * @param fileNamePatternToTrash pattern identifying files to remove without
	 * keeping a copy. The pattern
	 * can have the form <code>*string</code>, <code>string*</code>, or 
	 * <code>*string*</code> depending on whether the string is expected to be 
	 * at the end, the beginning, or in the middle of the last component of 
	 * the pathname.
     */
    static void archivePreviousResults(Job job, int restartCounter,
    		Set<String> fileNamePatternToCopy, 
    		Set<String> fileNamePatternToArchive,
    		Set<String> fileNamePatternToTrash)
    {
    	// Define the file system location where the job's files are located
		String path = ".";
		if (job.getUserDir()!=null)
			path = job.getUserDir().getAbsolutePath();
		File jobsRootPath = new File(path);
		if (!jobsRootPath.exists())
		{
            Terminator.withMsgAndStatus("ERROR! Folder '" + path
            		+ "' is expected to contain the data for job "
            		+ job.getId() + ", but is not found.", -1);   
		}
		
		// Collect all files related to this job and that may need to be 
		// archived (i.e., moved) to avoid overwriting upon job restart.
        Set<File> filesToArchive = new HashSet<File>();
        if (job.getStdOut()!=null)
        	filesToArchive.add(job.getStdOut());
        if (job.getStdErr()!=null)
        	filesToArchive.add(job.getStdErr());
        for (String pattern : fileNamePatternToArchive)
        { 
        	filesToArchive.addAll(FileUtils.find(jobsRootPath, pattern, true));
        }
        
        // Collect files that we want to copy instead of moving to the archive
        Set<File> filesToCopy = new HashSet<File>();
        for (String pattern : fileNamePatternToCopy)
        { 
        	filesToCopy.addAll(FileUtils.find(jobsRootPath, pattern, true));
        }
        
        // Collect files that we want to trash
        Set<File> filesToTrash = new HashSet<File>();
        for (String pattern : fileNamePatternToTrash)
        { 
        	filesToTrash.addAll(FileUtils.find(jobsRootPath, pattern, true));
        }
        Set<File> intersectionTrashArchive = SetUtils.getIntersection(
        		filesToTrash, filesToArchive);
        if (filesToTrash.removeAll(intersectionTrashArchive))
        {
        	//TODO-gg log
        	System.out.println("WARNING: the following files will not be "
        			+ "removed as they match one or more pattern for "
        			+ "archiving. " + StringUtils.mergeListToString(
        					Arrays.asList(intersectionTrashArchive), ",", true));
        }
        Set<File> intersectionTrashCopy = SetUtils.getIntersection(
        		filesToTrash, filesToCopy);
        if (filesToTrash.removeAll(intersectionTrashCopy))
        {
        	System.out.println("WARNING: the following files will not be "
        			+ "removed as they match one or more pattern for copying."
        			+ StringUtils.mergeListToString(
        					Arrays.asList(intersectionTrashCopy), ",", true));
        }
        
        // We do this here to be able to distinguish the two intersection cases 
        // above this point.
        filesToArchive.addAll(filesToCopy);
        
        //TODO-gg once addID is defined for comp.chem. software add 
        // default filenames based on the value of j.getAppID()
        
        Set<File> nonExisting = new HashSet<File>();
        for (File file : filesToArchive)
        {
        	if (!file.exists() || !file.canRead())
        	{
        		nonExisting.add(file);
        	}
        }
        filesToArchive.removeAll(nonExisting);
        
		if (filesToArchive.size()==0)
		{
			// Nothing else to do.
			return;
		}
		
    	File archiveFolder = new File(path + File.separator 
    			+ "Job_" + job.getId() + "_" + restartCounter);
        if (!archiveFolder.mkdirs())
        {
            Terminator.withMsgAndStatus("ERROR! Unable to create folder '"
            		+ archiveFolder+ "' for archiving partial results of "
            		+ "job.", -1);
        }
        String pathToArchive = archiveFolder.getAbsolutePath() 
        		+ File.separator;
        
        // Move/copy files into the archive 
        for (File file : filesToArchive)
        {
        	File newFile = new File(pathToArchive + file.getName());
        	try {
				Files.copy(file, newFile);
			} catch (IOException e) {
				System.out.println("WARNING: cannot copy file '" + file 
						+ "' to '" + newFile + "'. " + e.getMessage());
			}
        	if (!filesToCopy.contains(file))
        		file.delete();
        }
        
        // Cleanup files to trash
        for (File file : filesToTrash)
        {
        	file.delete();
        }
    }
   
//------------------------------------------------------------------------------
    
}
