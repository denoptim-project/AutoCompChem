package autocompchem.run.jobediting;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openscience.cdk.AtomContainerSet;
import org.openscience.cdk.interfaces.IAtomContainer;

import com.google.common.io.Files;

import autocompchem.datacollections.NamedData.NamedDataType;
import autocompchem.chemsoftware.ChemSoftConstants;
import autocompchem.datacollections.NamedDataCollector;
import autocompchem.perception.circumstance.Circumstance;
import autocompchem.perception.circumstance.ICircumstance;
import autocompchem.perception.infochannel.InfoChannel;
import autocompchem.perception.infochannel.InfoChannelType;
import autocompchem.perception.situation.Situation;
import autocompchem.run.Job;
import autocompchem.run.JobEvaluator;
import autocompchem.run.MonitoringJob;
import autocompchem.run.Terminator;
import autocompchem.run.jobediting.Action.ActionType;

/**
 * 
 */
public class ActionApplier 
{
    
//------------------------------------------------------------------------------
    
    public static List<IAtomContainer> getRestartGeoms(Action action, 
    		Job trigger)
    {
    	@SuppressWarnings("unchecked")
		Map<Integer, NamedDataCollector> jobOutputData = 
    			(Map<Integer, NamedDataCollector>) trigger.exposedOutput
    			.getNamedData(ChemSoftConstants.JOBOUTPUTDATA).getValue();
    	
    	int focusJobStepID = (int) trigger.exposedOutput.getNamedData(
    			JobEvaluator.NUMSTEPSKEY).getValue();
    	
    	NamedDataCollector stepData = jobOutputData.get(focusJobStepID);
    	AtomContainerSet acs = (AtomContainerSet) stepData
				.getNamedData(ChemSoftConstants.JOBDATAGEOMETRIES)
				.getValue();
    	
    	List<IAtomContainer> iacs = new ArrayList<IAtomContainer>();
    	
    	//TODO-gg modify to take any other than the last geometry found
    	// according to indication from action
    	iacs.add(acs.getAtomContainer(acs.getAtomContainerCount()-1));
    	
    	return iacs;
    }
	
//------------------------------------------------------------------------------

    /**
     * Performs the action that has been 
     * requested as a response to
     * a notification from a job (i.e., the trigger) and that affect one or more
     * jobs in the given list.
     * 
     * Note that any action is expected to be molecule-agnostic, so any change 
     * on job features that are dependent on the identify of the chemical system
     *  should not be done here.
	 * @param action The action requested by the trigger.
	 * @param trigger The job that triggered the request for action.
	 * @param todoJobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 */
    public static void performAction(Action action, 
    		Job trigger, List<Job> todoJobs, int restartCounter)
    {
    	Job focusJob = (Job) trigger.exposedOutput.getNamedData(
    			JobEvaluator.EVALUATEDJOB).getValue();
    	int focusJobStepID = (int) trigger.exposedOutput.getNamedData(
    			JobEvaluator.NUMSTEPSKEY).getValue();
    	
    	performAction(action, focusJob, focusJobStepID, todoJobs, 
    			restartCounter);
    }
	
//------------------------------------------------------------------------------

    /**
     * Performs the action that has been 
     * requested as a response to
     * a notification from a job (i.e., the trigger) and that affect one or more
     * jobs in the given list. 
     * Note that any action is expected to be molecule-agnostic, so any change 
     * on job features that are dependent on the identify of the chemical system
     *  should not be done here.
     * 
	 * @param action The action requested by the trigger.
	 * @param focusJob The job that failed or caused the triggering of the 
	 * action.
	 * @param focusJobStepId the index of the focus job in its list of steps.
	 * @param todoJobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 */
    static void performAction(Action action, Job focusJob, int focusJobStepId, 
    		List<Job> todoJobs, int restartCounter)
    {
    	ActionType aType = action.getType();
    	
    	// No need to archive or edit if the reaction is just to stop.
    	if (aType==ActionType.STOP)
    		return;
    	
    	//TODO-gg this is where action's setting will have to add additional rules
    	Set<File> filesToKeep = new HashSet<File>();
    	
    	// Create copy of previous data from jobs
    	archivePreviousResults(todoJobs, restartCounter, filesToKeep);
    	
    	// Trim job steps to have as first step the failing step
    	if (aType==ActionType.REDO && focusJobStepId>0 
    			&& focusJob.getNumberOfSteps()>0)
    	{
    		for (int i=0; i<focusJobStepId; i++)
    			focusJob.getSteps().remove(0);
    	}
    	
    	Job orinallyFailingStep = null;
    	if (focusJob.getNumberOfSteps()>0)
    	{
    		orinallyFailingStep = focusJob.getStep(0);
    	} else {
    		orinallyFailingStep = focusJob;
    	}

    	// Pre-pend (i.e., append in front) any step that should be appended
    	for (int i=(action.preliminarySteps.size()-1); i>-1; i--)
    	{
    		Job preliminaryStep = action.preliminarySteps.get(i);
    		for (IJobEditingTask jet : action.inheritedSettings)
    		{
    			//TODO-gg recover and generalize
    			//jet.inheritSettings(orinallyFailingStep, preliminaryStep);
    		}
    		focusJob.getSteps().add(0, preliminaryStep);
    	}
    	
    	// Modify job settings
    	for (IJobEditingTask jet : action.jobEditTasks)
    	{
    		jet.applyChange(focusJob);
    	}
    	
    	//NB: any data that may be needed to restart of fix things should be taken
    	// before resetting the jobs.
    	
    	// Reset status of all jobs to re-run them.
    	for (Job job : todoJobs)
    	{
    		job.resetRunStatus();
    	}
    }
    
//------------------------------------------------------------------------------
    
    /**
     * Moves files related to the given jobs into dedicated archive sub-folders
     * named after the <code>restartCounter</code>.
     * @param jobs list of jobs that may be altered by the action. None
	 * of these jobs should be running.
	 * @param restartCounter an unique counter used to archive data from 
	 * previous runs of the jobs that may be altered by the action. We use this 
	 * to create archives for existing data generated by previous runs of the
	 * jobs that may be altered.
	 * @param filesToKeep identifies files that, if present, should be copied
	 * instead of moved to the archive as they are needed to restart the jobs.
     */
    static void archivePreviousResults(List<Job> jobs, int restartCounter,
    		Set<File> filesToKeep)
    {
		for (Job j : jobs)
		{
			if (j instanceof MonitoringJob)
				continue;
			
			// Collect all files related to this job and that may need to be 
			// archived (i.e., moved) to avoid overwriting upon job restart.
	        Set<File> filesToArchive = new HashSet<File>();
	        if (j.getStdOut()!=null)
	        	filesToArchive.add(j.getStdOut());
	        if (j.getStdErr()!=null)
	        	filesToArchive.add(j.getStdErr());
	        
	        
	        //TODO-gg once addID is defined for comp.chem. software add 
	        // default filenames based on the value of j.getAppID()
	        
	        
	        //TODO-gg add some from rules defined in Action
	        
	        
	        Set<File> nonExisting = new HashSet<File>();
	        for (File file : filesToArchive)
	        {
	        	if (!file.exists() || !file.canRead())
	        	{
	        		nonExisting.add(file);
	        	}
	        }
	        filesToArchive.removeAll(nonExisting);
	        
			if (filesToArchive.size()==0)
				continue;
			
			String path = ".";
			if (j.getUserDir()!=null)
				path = j.getUserDir().getAbsolutePath();
	    	File archiveFolder = new File(path + File.separator 
	    			+ "Job_" + j.getId() + "_" + restartCounter);
	        if (!archiveFolder.mkdirs())
	        {
	            Terminator.withMsgAndStatus("ERROR! Unable to create folder '"
	            		+ archiveFolder+ "' for archiving partial results of "
	            		+ "job.", -1);
	        }
	        String pathToArchive = archiveFolder.getAbsolutePath() 
	        		+ File.separator;
	        
	        for (File file : filesToArchive)
	        {
	        	File newFile = new File(pathToArchive + file.getName());
	        	try {
					Files.copy(file, newFile);
				} catch (IOException e) {
					System.out.println("WARNING: cannot copy file '" + file 
							+ "' to '" + newFile + "'. " + e.getMessage());
				}
	        	if (!filesToKeep.contains(file))
	        		file.delete();
	        }
		}
    }
   
//------------------------------------------------------------------------------
    
}
